2006 05 26 1 1 1 2 create element get attribute value get attribute value write encoded 2006 05 02 xml element $ revision 1 4 $ $ date 2002 03 24 10 27 59 $ $ r e l e s e 2 2 1 $ nano xml 2 2000 2002 purpose 1 2 3 io xml element representation xml able parse xml < p>< d l> < d t>< b> parsing xml data< b>< d t> < d d> parse xml data using < u l>< o d e> xml element xml = xml element < b r> reader reader = reader filename xml < b r> xml parse reader reader < o d e>< u l>< d d>< d l> < d l>< d t>< b> retrieving attributes< b>< d t> < d d> enumerate attributes element using link #enumerate attribute names enumerate attribute names attribute values retrieved using link #get attribute get attribute example shows how list attributes element < u l>< o d e> xml element element = < b r> iterator iter = element get attribute names < b r> iter has next < b r> key = iter next < b r> value = element get attribute key < b r> out key + = + value < b r> < o d e>< u l>< d d>< d l> < d l>< d t>< b> retrieving child elements< b>< d t> < d d> enumerate children element using link #iterate children iterate children number child iterator retrieved using link #count children count children < d d>< d l> < d l>< d t>< b> elements containing character data< b>< d t> < d d> iterator contains character data like example < u l>< o d e> lt title title lt title < o d e>< u l> retrieve data using link #get content get content < d d>< d l> < d l>< d t>< b> subclassing xml element< b>< d t> < d d> when subclassing xml element need override link #create element create element which has copy receiver < d d>< d l> < p> author lt < href= mailto cyberelf mac com >cyberelf mac com< a> 2005 06 18 adapted 2 p i <br>$ r e l e s e 2 2 1 $ $ revision 1 4 $ see xml parse xml element serialization serial serial u = 6685035139346394777 l major nano xml classes same major minor are binary compatible classes same major are compatible major different need modify client see n n o xml m i n o r v e r s i o n n n o xml m j o r v e r s i o n = 2 minor nano xml classes same major minor are binary compatible classes same major are compatible major different need modify client see n n o xml m j o r v e r s i o n n n o xml m i n o r v e r s i o n = 2 attributes given element <dl><dt><b> invariants < b>< dt><dd> <ul><li> field empty <li> field never <code>null< code> <li> key set iterator values are strings < ul>< dd>< dl> hash map attributes child iterator element <dl><dt><b> invariants < b>< dt><dd> <ul><li> field empty <li> field never <code>null< code> <li> iterator are instances <code> xml element< code> subclass <code> xml element< code> < ul>< dd>< dl> list children element <dl><dt><b> invariants < b>< dt><dd> <ul><li> field <code>null< code> iff element initialized either parse set <li> field <code>null< code> s empty <li> field <code>null< code> contains valid xml identifier < ul>< dd>< dl> p d t content <dl><dt><b> invariants < b>< dt><dd> <ul><li> field <code>null< code> iff element p d t element <li> field empty < ul>< dd>< dl> contents conversion table amp entities key set iterator are entity names amp delimiters <dl><dt><b> invariants < b>< dt><dd> <ul><li> field never <code>null< code> <li> field always contains associations lt = lt = = \ apos = amp = amp <li> key set iterator are strings <li> values are arrays < ul>< dd>< dl> hash map entities line number where element starts <dl><dt><b> invariants < b>< dt><dd> <ul><li><code>line nr gt= 0< code> < ul>< dd>< dl> line nr <code>true< code> element attribute names are insensitive ignore <code>true< code> leading trailing whitespace p d t sections have ignored ignore whitespace character read too much character provides push back functionality input reader having pushback reader there character field \0 read too much reader caller parse <dl><dt><b> invariants < b>< dt><dd> <ul><li> field <code>null< code> parse running < ul>< dd>< dl> reader reader current line number content <dl><dt><b> invariants < b>< dt><dd> <ul><li>parser line nr 0 parse running < ul>< dd>< dl> parser line nr variable set are encoded entities encoding left underlying = creates initializes xml element calling construction equivalent <ul><code>new xml element hash map < code>< ul> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>count children = 0 <li>iterate children = empty enumeration <li>enumerate property names = empty enumeration <li>get children = empty vector <li>get content = <li>get line nr = 0 <li>get = < ul>< dd>< dl> see xml element hash map xml element hash map see xml element see xml element hash map xml element hash map xml element hash map creates initializes xml element calling construction equivalent <ul><code>new xml element entities < code>< ul> entities entity conversion table < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>entities != null< code> < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>count children = 0 <li>iterate children = empty enumeration <li>enumerate property names = empty enumeration <li>get children = empty vector <li>get content = <li>get line nr = 0 <li>get = < ul>< dd>< dl><dl> see xml element see xml element see xml element hash map xml element hash map xml element hash map entities entities creates initializes xml element calling construction equivalent <ul><code>new xml element hash map skip leading whitespace < code>< ul> skip leading whitespace <code>true< code> leading trailing whitespace p d t content has < dl><dl><dt><b> postconditions < b>< dt><dd> <ul><li>count children = 0 <li>iterate children = empty enumeration <li>enumerate property names = empty enumeration <li>get children = empty vector <li>get content = <li>get line nr = 0 <li>get = < ul>< dd>< dl><dl> see xml element see xml element hash map xml element hash map see xml element hash map xml element hash map xml element skip leading whitespace hash map skip leading whitespace creates initializes xml element calling construction equivalent <ul><code>new xml element entities skip leading whitespace < code>< ul> entities entity conversion table skip leading whitespace <code>true< code> leading trailing whitespace p d t content has < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>entities != null< code> < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>count children = 0 <li>iterate children = empty enumeration <li>enumerate property names = empty enumeration <li>get children = empty vector <li>get content = <li>get line nr = 0 <li>get = < ul>< dd>< dl><dl> see xml element see xml element see xml element hash map xml element hash map xml element hash map entities skip leading whitespace entities skip leading whitespace creates initializes xml element entities entity conversion table skip leading whitespace <code>true< code> leading trailing whitespace p d t content has ignore <code>true< code> element attribute names have ignored < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>entities != null< code> < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>count children = 0 <li>iterate children = empty enumeration <li>enumerate property names = empty enumeration <li>get children = empty vector <li>get content = <li>get line nr = 0 <li>get = < ul>< dd>< dl><dl> see xml element see xml element see xml element hash map xml element hash map see xml element hash map xml element hash map xml element hash map entities skip leading whitespace ignore entities skip leading whitespace ignore creates initializes xml element < p> constructor should < i>only< i> called link #create element create element create child iterator entities entity conversion table skip leading whitespace <code>true< code> leading trailing whitespace p d t content has fill basic conversion table <code>true< code> basic entities need entity list ignore <code>true< code> element attribute names have ignored < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>entities != null< code> <li>if <code>fill basic conversion table == false< code> then <code>entities< code> contains at least entries <code>amp< code> <code>lt< code> <code>gt< code> <code>apos< code> <code>quot< code> < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>count children = 0 <li>iterate children = empty enumeration <li>enumerate property names = empty enumeration <li>get children = empty vector <li>get content = <li>get line nr = 0 <li>get = < ul>< dd>< dl><dl> see #create element xml element hash map entities skip leading whitespace fill basic conversion table ignore entities skip leading whitespace fill basic conversion table ignore xml element hash map entities skip leading whitespace fill basic conversion table ignore ignore whitespace = skip leading whitespace ignore = ignore = contents = attributes = hash map children = list entities = entities line nr = 0 = iterator iter = entities key set iterator iter has next key = iter next value = entities get key value value = value entities put key value fill basic conversion table entities put amp entities put entities put apos \ entities put lt < entities put > adds child element child child element add < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>child != null< code> <li><code>child get != null< code> <li><code>child< code> does have parent element < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>count children = old count children + 1 <li>iterate children = old iterate children + child <li>get children = old iterate children + child < ul>< dd>< dl><dl> see #count children see #iterate children see #get children see #remove child xml element remove child xml element add child xml element child children add child adds modifies attribute attribute value value attribute < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier <li><code>value != null< code> < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>enumerate attribute names = old enumerate attribute names + <li>get attribute = value < ul>< dd>< dl><dl> set attribute value ignore = upper attributes put value adds modifies attribute attribute value value attribute < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>enumerate attribute names = old enumerate attribute names + <li>get attribute = value < ul>< dd>< dl><dl> set attribute value ignore = upper attributes put value adds modifies attribute attribute value value attribute < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>enumerate attribute names = old enumerate attribute names + <li>get attribute = value < ul>< dd>< dl><dl> set attribute value ignore = upper attributes put value number child iterator element <dl><dt><b> postconditions < b>< dt><dd> <ul><li><code>result >= 0< code> < ul>< dd>< dl> see #add child xml element add child xml element see #iterate children see #get children see #remove child xml element remove child xml element count children children size enumerates attribute names <dl><dt><b> postconditions < b>< dt><dd> <ul><li><code>result != null< code> < ul>< dd>< dl> iterator enumerate attribute names attributes key set iterator enumerates child iterator <dl><dt><b> postconditions < b>< dt><dd> <ul><li><code>result != null< code> < ul>< dd>< dl> iterator iterate children children iterator child iterator list safe modify list <dl><dt><b> postconditions < b>< dt><dd> <ul><li><code>result != null< code> < ul>< dd>< dl> see #add child xml element add child xml element see #count children see #iterate children see #remove child xml element remove child xml element list get children list children clone e never happens however some compilers are so braindead they require clause p d t content there content < o d e>null< o d e> see #set content set content get content contents line nr data on which element found <code>0< code> there associated data <dl><dt><b> postconditions < b>< dt><dd> <ul><li><code>result >= 0< code> < ul>< dd>< dl> get line nr line nr attribute element attribute doesn t <code>null< code> attribute < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier < ul>< dd>< dl><dl> get attribute get attribute attribute element attribute doesn t <code>default value< code> attribute value key attribute missing < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier < ul>< dd>< dl><dl> get attribute value ignore = upper value = attributes get value == value = value value attribute looking up key hashtable attribute doesn t value corresponding key < p> example value set contains mapping <code> one = 1 < code> element contains attribute <code>attr= one < code> then <code>get attribute attr mapping key < code> <code> 1 < code> attribute value set hash map mapping key set iterator values key key attribute missing allow literals <code>true< code> literals are valid < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier <li><code>value set< code> != <li>the key set iterator <code>value set< code> are strings < ul>< dd>< dl><dl> see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute names see #get attribute get attribute see #get attribute get attribute get attribute map value set key allow literals ignore = upper key = attributes get result key == key = key result = value set get key result == allow literals result = key invalid value key result attribute element attribute doesn t <code>null< code> attribute < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier < ul>< dd>< dl><dl> see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute names see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute get attribute attribute element attribute doesn t <code>default value< code> attribute value key attribute missing < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier < ul>< dd>< dl><dl> see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute names see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute value get attribute value attribute looking up key hashtable attribute doesn t value corresponding key < p> example value set contains mapping <code> one = 1 < code> element contains attribute <code>attr= one < code> then <code>get attribute attr mapping key < code> <code> 1 < code> attribute value set hash map mapping key set iterator values key key attribute missing allow literals <code>true< code> literals are valid < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier <li><code>value set< code> != <li>the key set iterator <code>value set< code> are strings <li>the values <code>value set< code> are strings < ul>< dd>< dl><dl> see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute names see #get attribute get attribute see #get attribute get attribute get attribute hash map value set key allow literals get attribute value set key allow literals attribute element attribute doesn t <code>0< code> attribute < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier < ul>< dd>< dl><dl> see #set attribute set attribute see #enumerate attribute names see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute get attribute 0 attribute element attribute doesn t <code>default value< code> attribute value key attribute missing < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier < ul>< dd>< dl><dl> see #set attribute set attribute see #enumerate attribute names see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute value ignore = upper value = attributes get value == value parse value number format e invalid value value get attribute value v = get attribute value v < v > v attribute looking up key hashtable attribute doesn t value corresponding key < p> example value set contains mapping <code> one = 1< code> element contains attribute <code>attr= one < code> then <code>get attribute attr mapping key < code> <code>1< code> attribute value set hash map mapping key set iterator values key key attribute missing allow literal numbers <code>true< code> literal numbers are valid < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier <li><code>value set< code> != <li>the key set iterator <code>value set< code> are strings <li>the values <code>value set< code> are <li><code>default key< code> either <code>null< code> key <code>value set< code> < ul>< dd>< dl><dl> see #set attribute set attribute see #enumerate attribute names see #get attribute get attribute see #get attribute get attribute get attribute hash map value set key allow literal numbers ignore = upper key = attributes get result key == key = key result = value set get key cast e invalid value set result == ! allow literal numbers invalid value key result = value key number format e invalid value key result value attribute element attribute doesn t <code>0 0< code> attribute < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier < ul>< dd>< dl><dl> see #set attribute set attribute see #enumerate attribute names see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute get attribute 0 attribute element attribute doesn t <code>default value< code> attribute value key attribute missing < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier < ul>< dd>< dl><dl> see #set attribute set attribute see #enumerate attribute names see #get attribute get attribute see #get attribute hash map get attribute hash map get attribute value ignore = upper value = attributes get value == value value value value number format e invalid value value attribute looking up key hashtable attribute doesn t value corresponding key < p> example value set contains mapping <code> one = 1 0< code> element contains attribute <code>attr= one < code> then <code>get attribute attr mapping key < code> <code>1 0< code> attribute value set hash map mapping key set iterator values key key attribute missing allow literal numbers <code>true< code> literal numbers are valid < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier <li><code>value set != null< code> <li>the key set iterator <code>value set< code> are strings <li>the values <code>value set< code> are <li><code>default key< code> either <code>null< code> key <code>value set< code> < ul>< dd>< dl><dl> see #set attribute set attribute see #enumerate attribute names see #get attribute get attribute see #get attribute get attribute get attribute hash map value set key allow literal numbers ignore = upper key = attributes get result key == key = key result = value set get key cast e invalid value set result == ! allow literal numbers invalid value key result = value key number format e invalid value key result value attribute element attribute doesn t <code>default value< code> value attribute equal <code>true value< code> <code>true< code> value attribute equal <code>false value< code> <code>false< code> value doesn t match <code>true value< code> <code>false value< code> thrown attribute value value associated <code>true< code> value value associated <code>true< code> value value attribute missing < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier <li><code>true value< code> <code>false value< code> are different strings < ul>< dd>< dl><dl> see #set attribute set attribute see #remove attribute remove attribute see #enumerate attribute names get attribute value value value ignore = upper value = attributes get value == value value equals value value equals value invalid value value get attribute value get attribute value element see #set set get reads one xml element io reader parses reader reader which retrieve xml data < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>reader != null< code> <li><code>reader< code> closed < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>the state receiver updated reflect xml element parsed reader <li>the reader points first character last character xml element < ul>< dd>< dl><dl> io i o occured reading input xml parse occured parsing read data parse reader reader reader i o xml parse parse reader reader starting line nr 1 reads one xml element io reader parses reader reader which retrieve xml data starting line nr line number first line data < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>reader != null< code> <li><code>reader< code> closed < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>the state receiver updated reflect xml element parsed reader <li>the reader points first character last character xml element < ul>< dd>< dl><dl> io i o occured reading input xml parse occured parsing read data parse reader reader reader starting line nr i o xml parse = contents = attributes = hash map children = list read too much = \0 reader = reader parser line nr = starting line nr ch = scan whitespace ch != < expected input < ch = read ch == ! || ch == ? skip special tag 0 unread ch scan element reads one xml element parses reader which retrieve xml data < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>string != null< code> <li><code>string length 0< code> < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>the state receiver updated reflect xml element parsed reader < ul>< dd>< dl><dl> xml parse occured parsing parse xml parse parse reader reader starting line nr 1 i o e handling suxx reads one xml element parses reader which retrieve xml data offset first character <code>string< code> scan < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>string != null< code> <li><code>offset lt length < code> <li><code>offset = 0< code> < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>the state receiver updated reflect xml element parsed reader < ul>< dd>< dl><dl> xml parse occured parsing parse offset xml parse parse substring offset reads one xml element parses reader which retrieve xml data offset first character <code>string< code> scan end character where stop scanning character scanned < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>string != null< code> <li><code>end lt = length < code> <li><code>offset lt end< code> <li><code>offset = 0< code> < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>the state receiver updated reflect xml element parsed reader < ul>< dd>< dl><dl> xml parse occured parsing parse offset end xml parse parse substring offset end reads one xml element parses reader which retrieve xml data offset first character <code>string< code> scan end character where stop scanning character scanned starting line nr line number first line data < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>string != null< code> <li><code>end lt = length < code> <li><code>offset lt end< code> <li><code>offset = 0< code> < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>the state receiver updated reflect xml element parsed reader < ul>< dd>< dl><dl> xml parse occured parsing parse offset end starting line nr xml parse = substring offset end parse reader reader starting line nr i o e handling suxx reads one xml element parses input reader which retrieve xml data offset first character <code>string< code> scan end character where stop scanning character scanned < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>input != null< code> <li><code>end lt = input length< code> <li><code>offset lt end< code> <li><code>offset = 0< code> < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>the state receiver updated reflect xml element parsed reader < ul>< dd>< dl><dl> xml parse occured parsing parse input offset end xml parse parse input offset end starting line nr 1 reads one xml element parses input reader which retrieve xml data offset first character <code>string< code> scan end character where stop scanning character scanned starting line nr line number first line data < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>input != null< code> <li><code>end lt = input length< code> <li><code>offset lt end< code> <li><code>offset = 0< code> < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>the state receiver updated reflect xml element parsed reader < ul>< dd>< dl><dl> xml parse occured parsing parse input offset end starting line nr xml parse reader reader = reader input offset end parse reader reader starting line nr i o e never happen removes child element child child element remove < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>child != null< code> <li><code>child< code> child element receiver < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>count children = old count children 1 <li>iterate children = old iterate children child <li>get children = old iterate children child < ul>< dd>< dl><dl> see #add child xml element add child xml element see #count children see #iterate children see #get children remove child xml element child children remove child removes attribute attribute < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li>enumerate attribute names = old enumerate attribute names <li>get attribute = <code>null< code> < ul>< dd>< dl><dl> remove attribute ignore = upper attributes remove creates similar xml element xml element create element xml element elem = create element elem set elem creates similar xml element < p> should override when subclassing xml element xml element create element xml element entities ignore whitespace ignore changes content content content set content content contents = content changes element < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name< code> valid xml identifier < ul>< dd>< dl> see #get set = writes xml element see #write io write output stream out = output stream output stream = output stream out write flush out i o e handling suxx writes xml element write xml data < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>writer != null< code> <li><code>writer< code> closed < ul>< dd>< dl> io i o data could written see #to write i o == write encoded contents write < write ! attributes empty iterator iter = attributes key set iterator iter has next write key = iter next value = attributes get key write key write = write write encoded value write contents != contents length > 0 write > write encoded contents write < write write write > children empty write write > write > iterator iter = iterate children iter has next xml element child = xml element iter next child write write < write write write > writes xml element indents elements write xml data < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>writer != null< code> <li><code>writer< code> closed < ul>< dd>< dl> io i o data could written see #to 0 writes xml element indents elements write xml data < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>writer != null< code> <li><code>writer< code> closed < ul>< dd>< dl> indent indentation io i o data could written see #to indent == write encoded contents spaces = indent 2 arrays fill spaces write spaces write < write ! attributes empty iterator enm = attributes key set iterator enm has next write key = enm next value = attributes get key write key write = write write encoded value write contents != contents length > 0 write > write encoded contents write < write write write > children empty write write > write > write iterator enm = get children iterator enm has next xml element child = xml element enm next child indent + 1 write spaces write < write write write > write i o e internal = internal e get message init cause e writes encoded write xml data str write encoded < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>writer != null< code> <li><code>writer< code> closed <li><code>str != null< code> < ul>< dd>< dl> write encoded str i o i = 0 i < str length i += 1 ch = str at i ch < write write l write t write > write write g write t write write write write m write p write write write q write u write o write t write \ write write write p write o write s write = ch < 32 || > 126 write write write x write 16 write write ch scans identifier current reader scanned identifier appended <code>result< code> result buffer which scanned identifier put < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>result != null< code> <li> next character read reader valid first character xml identifier < ul>< dd>< dl> <dl><dt><b> postconditions < b>< dt><dd> <ul><li> next character read reader won t identifier character < ul>< dd>< dl><dl> scan identifier buffer result i o ch = read ch < || ch > z ch < || ch > z ch < 0 || ch > 9 ch != ch != ch != ch != ch <= \u007 e unread ch result append ch scans identifier current reader next character whitespace scan whitespace i o ch = read ch \r ch scans identifier current reader scanned whitespace appended <code>result< code> next character whitespace < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>result != null< code> < ul>< dd>< dl> scan whitespace buffer result i o ch = read ch result append ch \r ch scans delimited current reader scanned delimiters appended <code>string< code> < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>string != null< code> <li>the next read delimiter < ul>< dd>< dl> scan buffer i o delimiter = read delimiter != \ delimiter != expected input \ ch = read ch == delimiter ch == resolve entity append ch scans p d t element d t sections entities are resolved next lt skipped scanned data appended <code>data< code> < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>data != null< code> < ul>< dd>< dl> scan p data buffer data i o ch = read ch == < ch = read ch == ! check d t data unread ch ch == resolve entity data data append ch scans special tag tag d t section append content <code>buf< code> < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>buf != null< code> <li> first lt has already been read < ul>< dd>< dl> check d t buffer buf i o ch = read ch != unread ch skip special tag 0 ! check literal d t skip special tag 1 one has already been read delimiter chars skipped = 0 delimiter chars skipped < 3 ch = read ch delimiter chars skipped < 2 delimiter chars skipped += 1 buf append buf append delimiter chars skipped = 0 > delimiter chars skipped < 2 i = 0 i < delimiter chars skipped i++ buf append delimiter chars skipped = 0 buf append > delimiter chars skipped = 3 i = 0 i < delimiter chars skipped i += 1 buf append buf append ch delimiter chars skipped = 0 skips comment < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li> first lt ! has already been read < ul>< dd>< dl> skip comment i o dashes read = 2 dashes read > 0 ch = read ch == dashes read = 1 dashes read = 2 read != > expected input > skips special tag comment bracket level number open square brackets have already been read < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li> first lt ! has already been read <li><code>bracket level >= 0< code> < ul>< dd>< dl> skip special tag bracket level i o tag level = 1 < delimiter = \0 bracket level == 0 ch = read ch == bracket level += 1 ch == ch = read ch == bracket level += 1 ch == bracket level = 1 ch == skip comment tag level > 0 ch = read delimiter == \0 ch == || ch == \ delimiter = ch bracket level <= 0 ch == < tag level += 1 ch == > tag level = 1 ch == bracket level += 1 ch == bracket level = 1 ch == delimiter delimiter = \0 scans data literal text scanning stops when character does match after complete text has been checked whichever comes first literal literal check < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>literal != null< code> < ul>< dd>< dl> check literal literal i o length = literal length i = 0 i < length i += 1 read != literal at i reads character reader read i o read too much != \0 ch = read too much read too much = \0 ch i = reader read i < 0 unexpected end data i == 10 parser line nr += 1 i scans xml element elt element contain result < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li> first lt has already been read <li><code>elt != null< code> < ul>< dd>< dl> scan element xml element elt i o buffer buf = buffer scan identifier buf = buf elt set ch = scan whitespace ch != > ch != buf set length 0 unread ch scan identifier buf key = buf ch = scan whitespace ch != = expected input = unread scan whitespace buf set length 0 scan buf elt set attribute key buf ch = scan whitespace ch == ch = read ch != > expected input > buf set length 0 ch = scan whitespace buf ch != < unread ch scan p data buf ch = read ch == ! check d t buf scan p data buf ch = scan whitespace buf ch != < unread ch scan p data buf ch != || ignore whitespace buf set length 0 ch == unread ch buf length == 0 ch != ch == ! ch = read ch != expected input comment element ch = read ch != expected input comment element skip comment unread ch xml element child = create element scan element child elt add child child ch = scan whitespace ch != < expected input < ch = read unread ch ignore whitespace elt set content buf trim elt set content buf ch = read ch != expected input unread scan whitespace ! check literal expected input scan whitespace != > expected input > resolves entity entity read reader value entity appended <code>buf< code> buf where put entity value < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li> first amp has already been read <li><code>buf != null< code> < ul>< dd>< dl> resolve entity buffer buf i o ch = \0 buffer key buf = buffer ch = read ch == key buf append ch key = key buf key at 0 == key at 1 == x ch = parse key substring 2 16 ch = parse key substring 1 10 number format e unknown entity key buf append ch value = entities get key value == unknown entity key buf append value pushes character back read back buffer ch character push back < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li> read back buffer empty <li><code>ch != \0 < code> < ul>< dd>< dl> unread ch read too much = ch creates parse when invalid valueset given entity < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> < ul>< dd>< dl> xml parse invalid value set msg = invalid value set entity = \ + + \ xml parse get parser line nr msg creates parse when invalid value given entity value value entity < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>value != null< code> < ul>< dd>< dl> xml parse invalid value value msg = attribute \ + + \ does contain valid + value \ + value + \ xml parse get parser line nr msg creates parse when end data input has been reached xml parse unexpected end data msg = unexpected end data reached xml parse get parser line nr msg creates parse when syntax occured context context which occured < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>context != null< code> <li><code>context length 0< code> < ul>< dd>< dl> xml parse syntax context msg = syntax parsing + context xml parse get parser line nr msg creates parse when next character read character was expected set set human readable form was expected < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>char set != null< code> <li><code>char set length 0< code> < ul>< dd>< dl> xml parse expected input set msg = expected + set xml parse get parser line nr msg creates parse when entity could resolved entity < dl><dl><dt><b> preconditions < b>< dt><dd> <ul><li><code>name != null< code> <li><code>name length 0< code> < ul>< dd>< dl> xml parse unknown entity msg = unknown invalid entity + + xml parse get parser line nr msg 
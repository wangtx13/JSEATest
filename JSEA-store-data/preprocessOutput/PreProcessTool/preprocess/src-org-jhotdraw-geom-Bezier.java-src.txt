bezier 2 0 1 2006 06 14 1996 2006 disclose accordance geom geom provides algorithms fitting bezier curves set digitized points <p> <br> algorithm automatically fitting digitized curves philip j schneider <br> graphics gems academic press 1990 2 0 1 2006 06 14 fit bezier curve preserve closed state fitted bezier path <br>2 0 2006 01 14 support precision coordinates <br>1 0 march 14 2004 author bezier most points have m x p o i n t s = 1000 prevent instance creation bezier example how curve fitting given points tolerance squared between points fitted curve algorithm generate piecewise cubic bezier representation approximates points when cubic generated routine draw bezier curve called which outputs bezier curve just created arguments are degree control points respectively users have implement function themselves ascii output etc point2 d d = digitized points point2 d 0 0 0 0 point2 d 0 0 0 5 point2 d 1 1 1 4 point2 d 2 1 1 6 point2 d 3 2 1 1 point2 d 4 0 0 2 point2 d 4 0 0 0 = 4 0 squared general path path = fit curve d fit bezier curves out path fit bezier curve set digitized points p polygon set digitized points user defined squared general path containing bezier curves general path fit curve polygon p point2 d d = point2 d p npoints i=0 i < d length i++ d i = point2 d p xpoints i p ypoints i fit curve d fit bezier curve set digitized points d digitized points user defined squared general path containing bezier curves general path fit curve point2 d d point2 d t hat1 = point2 d point2 d t hat2 = point2 d unit tangent vectors at endpoints general path bezier path = general path bezier path move d 0 x d 0 y t hat1 = compute left tangent d 0 t hat2 = compute right tangent d d length 1 fit cubic d 0 d length 1 t hat1 t hat2 bezier path bezier path fit bezier curve set digitized points path path onto which fit bezier curve user defined squared bezier path containing bezier curves bezier path fit bezier curve bezier path path point2 d d = path polygon point2 d t hat1 = point2 d point2 d t hat2 = point2 d unit tangent vectors at endpoints bezier path bezier path = bezier path bezier path add bezier path node d 0 t hat1 = compute left tangent d 0 t hat2 = compute right tangent d d length 1 fit cubic d 0 d length 1 t hat1 t hat2 bezier path bezier path set closed path closed bezier path fit bezier curve sub set digitized points d digitized points first indice first point d last indice last point d t hat1 unit tangent vectors at start point t hat2 unit tanget vector at end point user defined squared bezier path path which bezier curve segments are fit cubic point2 d d first last point2 d t hat1 point2 d t hat2 general path bezier path point2 d bez curve control points fitted bezier curve u parameter values point u prime improved parameter values maximum fitting split point = 1 point split point set at size one because we need input output parameter n pts number points subset iteration below which iterating iterations = 4 times iterating point2 d t hat center = point2 d unit tangent vector at split point i iteration = n pts = last first + 1 heuristic region has two points n pts == 2 dist = v2 distance between2 points d last d first 3 0 bez curve = point2 d 4 i=0 i < bez curve length i++ bez curve i = point2 d bez curve 0 = d first bez curve 3 = d last v2 add bez curve 0 v2 scale t hat1 dist bez curve 1 v2 add bez curve 3 v2 scale t hat2 dist bez curve 2 bezier path curve bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y parameterize points attempt fit curve u = chord length parameterize d first last bez curve = generate bezier d first last u t hat1 t hat2 find deviation points fitted curve = compute d first last bez curve u split point < bezier path curve bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y too large some reparameterization iteration < iteration i = 0 i < iterations i++ u prime = reparameterize d first last u bez curve bez curve = generate bezier d first last u prime t hat1 t hat2 = compute d first last bez curve u prime split point < bezier path curve bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y u = u prime fitting failed split at point fit recursively t hat center = compute center tangent d split point 0 fit cubic d first split point 0 t hat1 t hat center bezier path v2 negate t hat center fit cubic d split point 0 last t hat center t hat2 bezier path fit bezier curve sub set digitized points d digitized points first indice first point d last indice last point d t hat1 unit tangent vectors at start point t hat2 unit tanget vector at end point user defined squared bezier path path which bezier curve segments are fit cubic point2 d d first last point2 d t hat1 point2 d t hat2 bezier path bezier path point2 d bez curve control points fitted bezier curve u parameter values point u prime improved parameter values maximum fitting split point = 1 point split point set at size one because we need input output parameter n pts number points subset iteration below which iterating iterations = 4 times iterating point2 d t hat center = point2 d unit tangent vector at split point i iteration = n pts = last first + 1 heuristic region has two points n pts == 2 dist = v2 distance between2 points d last d first 3 0 bez curve = point2 d 4 i=0 i < bez curve length i++ bez curve i = point2 d bez curve 0 = d first bez curve 3 = d last v2 add bez curve 0 v2 scale t hat1 dist bez curve 1 v2 add bez curve 3 v2 scale t hat2 dist bez curve 2 bezier path curve bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y parameterize points attempt fit curve u = chord length parameterize d first last bez curve = generate bezier d first last u t hat1 t hat2 find deviation points fitted curve = compute d first last bez curve u split point < bezier path curve bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y too large some reparameterization iteration < iteration i = 0 i < iterations i++ u prime = reparameterize d first last u bez curve bez curve = generate bezier d first last u prime t hat1 t hat2 = compute d first last bez curve u prime split point < bezier path curve bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y u = u prime fitting failed split at point fit recursively t hat center = compute center tangent d split point 0 fit cubic d first split point 0 t hat1 t hat center bezier path v2 negate t hat center fit cubic d split point 0 last t hat center t hat2 bezier path least squares find bezier control points region d digitized points first indice first point d last indice last point d u prime parameter values region t hat1 unit tangent vectors at start point t hat2 unit tanget vector at end point point2 d generate bezier point2 d d first last u prime point2 d t hat1 point2 d t hat2 i point2 d = point2 d m x p o i n t s 2 precomputed rhs eqn n pts number pts sub curve = 2 2 matrix x = 2 matrix x det c0 c1 determinants matrices det c0 x det x c1 alpha l alpha values left right alpha r point2 d tmp = point2 d utility variable point2 d bez curve r e t u r n bezier curve ctl pts bez curve = point2 d 4 i=0 i < bez curve length i++ bez curve i = point2 d n pts = last first + 1 compute s i = 0 i < n pts i++ point2 d v1 v2 v1 = point2 d t hat1 clone v2 = point2 d t hat2 clone v2 scale v1 b1 u prime i v2 scale v2 b2 u prime i i 0 = v1 i 1 = v2 create x matrices 0 0 = 0 0 0 1 = 0 0 1 0 = 0 0 1 1 = 0 0 x 0 = 0 0 x 1 = 0 0 i = 0 i < n pts i++ 0 0 += v2 dot i 0 i 0 0 1 += v2 dot i 0 i 1 1 0 += v2 dot i 0 i 1 1 0 = 0 1 1 1 += v2 dot i 1 i 1 tmp = v2 sub i i d first + i v2 add i i v2 scale i i i d first b0 u prime i v2 add i i v2 scale i i i d first b1 u prime i v2 add i i v2 scale i i i d last b2 u prime i v2 scale i i i d last b3 u prime i x 0 += v2 dot i 0 tmp x 1 += v2 dot i 1 tmp compute determinants x det c0 c1 = 0 0 1 1 1 0 0 1 det c0 x = 0 0 x 1 0 1 x 0 det x c1 = x 0 1 1 x 1 0 1 derive alpha values det c0 c1 == 0 0 det c0 c1 = 0 0 1 1 10e 12 alpha l = det x c1 det c0 c1 alpha r = det c0 x det c0 c1 alpha negative wu barsky heuristic see text alpha 0 get coincident control points divide zero subsequent newton raphson root find call alpha l < 1 0e 6 || alpha r < 1 0e 6 dist = v2 distance between2 points d last d first 3 0 bez curve 0 = d first bez curve 3 = d last v2 add bez curve 0 v2 scale t hat1 dist bez curve 1 v2 add bez curve 3 v2 scale t hat2 dist bez curve 2 bez curve first last control points bezier curve are positioned exactly at first last data points control points 1 2 are positioned alpha distance out on tangent vectors left right respectively bez curve 0 = d first bez curve 3 = d last v2 add bez curve 0 v2 scale t hat1 alpha l bez curve 1 v2 add bez curve 3 v2 scale t hat2 alpha r bez curve 2 bez curve given set points their parameterization find better parameterization d digitized points first indice first point region d last indice last point region d u current parameter values bez curve current fitted curve reparameterize point2 d d first last u point2 d bez curve n pts = last first+1 i u prime parameter values u prime = n pts i = first i <= last i++ u prime i first = newton raphson root find bez curve d i u i first u prime newton raphson iteration find better root q current fitted bezier curve p digitized point u parameter value vor p newton raphson root find point2 d q point2 d p u numerator denominator point2 d q1 = point2 d 3 q2 = point2 d 2 q q point2 d q u = point2 d q1 u = point2 d q2 u = point2 d u evaluated at q q q u prime improved u i compute q u q u = bezier i i 3 q u generate control vertices q i = 0 i <= 2 i++ q1 i = point2 d q i+1 x q i x 3 0 q i+1 y q i y 3 0 generate control vertices q i = 0 i <= 1 i++ q2 i = point2 d q1 i+1 x q1 i x 2 0 q1 i+1 y q1 i y 2 0 compute q u q u q1 u = bezier i i 2 q1 u q2 u = bezier i i 1 q2 u compute f u f u numerator = q u x p x q1 u x + q u y p y q1 u y denominator = q1 u x q1 u x + q1 u y q1 u y + q u x p x q2 u x + q u y p y q2 u y u = u f u f u u prime = u numerator denominator u prime evaluate bezier curve at particular parameter value degree degree bezier curve v control points t parametric value find point point2 d bezier i i degree point2 d v t i j point2 d q point on curve at parameter t point2 d vtemp local copy control points copy vtemp = point2 d degree+1 i = 0 i <= degree i++ vtemp i = point2 d v i clone triangle computation i = 1 i <= degree i++ j = 0 j <= degree i j++ vtemp j x = 1 0 t vtemp j x + t vtemp j+1 x vtemp j y = 1 0 t vtemp j y + t vtemp j+1 y q = vtemp 0 q b0 b1 b2 b3 bezier multipliers b0 u tmp = 1 0 u tmp tmp tmp b1 u tmp = 1 0 u 3 u tmp tmp b2 u tmp = 1 0 u 3 u u tmp b3 u u u u approximate unit tangents at left endpoint digitized curve d digitized points end index left end region point2 d compute left tangent point2 d d end point2 d t hat1 = point2 d t hat1 = v2 sub i i d end+1 d end t hat1 = v2 normalize t hat1 t hat1 approximate unit tangents at right endpoint digitized curve d digitized points end index right end region point2 d compute right tangent point2 d d end point2 d t hat2 = point2 d t hat2 = v2 sub i i d end 1 d end t hat2 = v2 normalize t hat2 t hat2 approximate unit tangents at center digitized curve d digitized points center index center end region point2 d compute center tangent point2 d d center point2 d v1 = point2 d v2 = point2 d t hat center = point2 d v1 = v2 sub i i d center 1 d center v2 = v2 sub i i d center d center+1 t hat center x = v1 x + v2 x 2 0 t hat center y = v1 y + v2 y 2 0 t hat center = v2 normalize t hat center t hat center assign parameter values digitized points using relative distances between points d digitized points first indice first point region d last indice last point region d chord length parameterize point2 d d first last i u parameterization u = last first+1 u 0 = 0 0 i = first+1 i <= last i++ u i first = u i first 1 + v2 distance between2 points d i d i 1 i = first + 1 i <= last i++ u i first = u i first u last first u find maximum squared distance digitized points fitted curve d digitized points first indice first point region d last indice last point region d bez curve fitted bezier curve u parameterization points split point point maximum input output parameter 1 compute point2 d d first last point2 d bez curve u split point i dist maximum dist current point2 d p = point2 d point on curve point2 d v = point2 d vector point curve split point 0 = last first + 1 2 dist = 0 0 i = first + 1 i < last i++ p = bezier i i 3 bez curve u i first v = v2 sub i i p d i dist = v2 squared length v dist >= dist dist = dist split point 0 = i dist point2 d v2 add i i point2 d point2 d b point2 d = point2 d x = x + b x y = y + b y point2 d v2 scale i i i point2 d v s point2 d result = point2 d result x = v x s result y = v y s result point2 d v2 sub i i point2 d point2 d b point2 d = point2 d x = x b x y = y b y graphics gems 2d 3d vector library andrew glassner graphics gems academic press 1990 distance between two points v2 distance between2 points point2 d point2 d b dx = x b x dy = y b y math sqrt dx dx + dy dy scales input vector length point2 d v2 scale point2 d v newlen len = v2 length v len != 0 0 v x = newlen len v y = newlen len v length input vector v2 length point2 d math sqrt v2 squared length squared length input vector v2 squared length point2 d x x + y y vector sum = a+b point2 d v2 add point2 d point2 d b point2 d x = x+b x y = y+b y negates input vector point2 d v2 negate point2 d v v x = v x v y = v y v dot vectors b v2 dot point2 d point2 d b x b x + y b y normalizes input vector point2 d v2 normalize point2 d v len = v2 length v len != 0 0 v x = len v y = len v 
bezier path 1 1 2006 03 22 1996 2006 disclose accordance geom geom bezier path allows construction paths consisting straight lines quadratic curves cubic curves <p> bezier path represents geometric path constructed vertices each node has three control points c0 c1 c2 mask defines which control points are path passes through c0 c1 controls curve going towards c0 c2 controls curve going away c0 author 1 1 2006 03 22 move line quad <br>1 0 january 20 2006 created bezier path list< bezier path node> shape constant control point c1 c1 m s k = 1 constant control point c2 c2 m s k = 2 convenience constant control point c1 c2 c1 c2 m s k = c1 m s k | c2 m s k we cache general path instance speed up shape operations general path general path we cache index outermost node speed up index outermost node outer = 1 value set closes bezier path closed defines vertex node bezier path <p> vertex consists three control points c0 c1 c2 <ul> <li> bezier path always passes through c0 < li> <li> c1 used control curve towards c0 < li> <li> c2 used control curve going away c0 < li> < ul> node cloneable mask used describe which control points addition c0 are effect mask = 0 control point x coordinates x = 3 control point y coordinates y = 3 hint editing tools set editing tools keep control points on same line keep colinear = node mask = 1 node node set set node mask = mask keep colinear = keep colinear arraycopy x 0 x 0 3 arraycopy y 0 y 0 3 node point2 d c0 mask = 0 x 0 = c0 x y 0 = c0 y x 1 = c0 x y 1 = c0 y x 2 = c0 x y 2 = c0 y node mask point2 d c0 point2 d c1 point2 d c2 mask = mask x 0 = c0 x y 0 = c0 y x 1 = c1 x y 1 = c1 y x 2 = c2 x y 2 = c2 y node x0 y0 mask = 0 x 0 = x0 y 0 = y0 x 1 = x0 y 1 = y0 x 2 = x0 y 2 = y0 node mask x0 y0 x1 y1 x2 y2 mask = mask x 0 = x0 y 0 = y0 x 1 = x1 y 1 = y1 x 2 = x2 y 2 = y2 get mask mask set mask value mask = value set control point index point2 d p x index = p x y index = p y point2 d get control point index point2 d x index y index move point2 d p move p x x 0 p y y 0 move x y move x x 0 y y 0 move dx dy i=0 i < 3 i++ x i += dx y i += dy clone node = node clone x = x clone y = y clone clone supported e internal = internal init cause e builder buf = builder buf append i=0 i < 3 i++ i != 0 mask i == i buf append buf append x buf append i buf append = buf append x i buf append y buf append i buf append = buf append y i buf append buf creates instance bezier path convenience adding control point single coordinate c0 add point2 d c0 add node 0 c0 c0 c0 add point x y add node 0 x y x y x y convenience adding control point three coordinates c0 c1 c2 mask add mask point2 d c0 point2 d c1 point2 d c2 add node mask c0 c1 c2 convenience changing single coordinate control point set index coord point2 d p node = get index x coord = p x y coord = p y convenience getting single coordinate control point point2 d get index coord node = get index point2 d x coord y coord called after bezier path has been invalidate path general path = outer = 1 recomputes bezier path invalid validate path general path == general path = general path converts bezier path general path general path general path general path gp = general path gp set winding rule general path i n d e v e n o d d size == 0 gp move 0 0 gp line 0 0 + 1 size == 1 node current = get 0 gp move current x 0 current y 0 gp line current x 0 current y 0 + 1 node previous node current previous = current = get 0 gp move current x 0 current y 0 i=1 n = size i < n i++ previous = current current = get i previous mask c2 m s k == 0 current mask c1 m s k == 0 gp line current x 0 current y 0 gp quad current x 1 current y 1 current x 0 current y 0 current mask c1 m s k == 0 gp quad previous x 2 previous y 2 current x 0 current y 0 gp curve previous x 2 previous y 2 current x 1 current y 1 current x 0 current y 0 closed size > 1 previous = get size 1 current = get 0 previous mask c2 m s k == 0 current mask c1 m s k == 0 gp line current x 0 current y 0 gp quad current x 1 current y 1 current x 0 current y 0 current mask c1 m s k == 0 gp quad previous x 2 previous y 2 current x 0 current y 0 gp curve previous x 2 previous y 2 current x 1 current y 1 current x 0 current y 0 gp close path gp contains point2 d p validate path general path contains p outline bezier path contains specified point p point tested tolerance tolerance test outline contains point2 d p tolerance validate path path iterator i = general path get path iterator affine transform tolerance coords = 6 type = i current segment coords prev x = coords 0 prev y = coords 1 i next ! i done i current segment coords geom line contains point prev x prev y coords 0 coords 1 p x p y tolerance prev x = coords 0 prev y = coords 1 i next intersects rectangle2 d r validate path general path intersects r path iterator get path iterator affine transform at validate path general path get path iterator at contains rectangle2 d r validate path general path contains r path iterator get path iterator affine transform at flatness validate path general path get path iterator at flatness intersects x y h validate path general path intersects x y h rectangle2 d get bounds2 d validate path general path get bounds2 d rectangle2 d get bounds2 d validate path rectangle2 d r = general path get bounds2 d r rectangle2 d rectangle2 d r rectangle2 d r get x r get y r get width r get height rectangle get bounds validate path general path get bounds contains x y h validate path general path contains x y h contains x y validate path general path contains x y set closed value closed != value closed = value invalidate path closed closed creates deep copy bezier path clone bezier path = bezier path clone i=0 n = size i < n i++ set i node get i clone transforms bezier path tx transformation transform affine transform tx point2 d p = point2 d node cp i=0 i < 3 i++ p x = cp x i p y = cp y i tx transform p p cp x i = p x cp y i = p y invalidate path set bezier path size < size remove size 1 i=0 n = size i < n i++ get i set get i size < size add node get size clone point at center bezier path point2 d get center sx = 0 sy = 0 node p sx += p x 0 sy += p y 0 n = size point2 d sx n sy n point on edge bezier path which crosses line center bezier path specified point edge crosses line nearest c0 control point point2 d chop point2 d p validate path geom chop general path p point2 d ctr = get center chopped point cx = 1 cy = 1 len = m x v l u e points along edge validate path path iterator i = general path get path iterator affine transform 1 coords = 6 type = i current segment coords prev x = coords 0 prev y = coords 1 i next ! i done i next i current segment coords point2 d chop = geom intersect prev x prev y coords 0 coords 1 p x p y ctr x ctr y chop != cl = geom length2 chop x chop y p x p y cl < len len = cl cx = chop x cy = chop y prev x = coords 0 prev y = coords 1 closed size > 1 node first = get 0 node last = get size 1 point2 d chop = geom intersect first x 0 first y 0 last x 0 last y 0 p x p y ctr x ctr y chop != cl = geom length2 chop x chop y p x p y cl < len len = cl cx = chop x cy = chop y none found pick closest vertex len == m x v l u e j = 0 n = size j < n j++ node cp = get j l = geom length2 cp x 0 cp y 0 p x p y l < len len = l cx = cp x 0 cy = cp y 0 point2 d cx cy index control point furthest center index outermost node outer == 1 point2 d ctr = get center outer = 0 dist = 0 i = 0 n = size i < n i++ node cp = get i d = geom length2 ctr x ctr y cp x 0 cp y 0 d > dist dist = d outer = i outer relative point on path where 0 start point path 1 end point path relative value between 0 1 point2 d get point on path relative flatness size == 0 size == 1 get 0 get control point 0 relative <= 0 get 0 get control point 0 relative >= 1 get size 1 get control point 0 validate path determine length path len = 0 path iterator i = general path get path iterator affine transform flatness coords = 6 type = i current segment coords prev x = coords 0 prev y = coords 1 i next ! i done i next i current segment coords len += geom length prev x prev y coords 0 coords 1 prev x = coords 0 prev y = coords 1 compute relative point on path relative len = len relative pos = 0 i = general path get path iterator affine transform flatness type = i current segment coords prev x = coords 0 prev y = coords 1 i next ! i done i next i current segment coords seg len = geom length prev x prev y coords 0 coords 1 pos + seg len >= relative len point2 d coords 0 coords 1 compute relative point2 d on line point2 d prev x pos len + coords 0 pos + seg len len prev y pos len + coords 1 pos + seg len len factor = relative len pos seg len point2 d prev x 1 factor + coords 0 factor prev y 1 factor + coords 1 factor pos += seg len prev x = coords 0 prev y = coords 1 internal we should never get here gets segment polyline hit given point2 d index segment 1 segment was hit find segment point2 d find tolerance x x x works straight lines! node v1 v2 bezier path temp path = bezier path node t1 t2 temp path add t1 = node temp path add t2 = node i = 0 n = size 1 i < n i++ v1 = get i v2 = get i+1 v1 mask == 0 v2 mask == 0 geom line contains point v1 x 0 v1 y 0 v2 x 0 v2 y 0 find x find y tolerance i t1 set v1 t2 set v2 temp path invalidate path temp path outline contains find tolerance i closed size > 1 v1 = get size 1 v2 = get 0 v1 mask == 0 v2 mask == 0 geom line contains point v1 x 0 v1 y 0 v2 x 0 v2 y 0 find x find y tolerance size 1 t1 set v1 t2 set v2 temp path invalidate path temp path outline contains find tolerance size 1 1 joins two segments one given point2 d hits node bezier path index joined segment 1 segment was joined join segments point2 d join tolerance i=0 i < size i++ node p = get i geom length p x 0 p y 0 join x join y < tolerance remove i i 1 splits segment at given point2 d segment was hit index segment 1 segment was hit split segment point2 d split tolerance i = find segment split tolerance next i = i + 1 % size i != 1 get i mask c2 m s k == c2 m s k get next i mask c1 m s k == 0 quadto add i + 1 node c2 m s k split split split get i mask c2 m s k == 0 get next i mask c1 m s k == c1 m s k quadto add i + 1 node c2 m s k split split split get i mask c2 m s k == c2 m s k get next i mask c1 m s k == c2 m s k cubicto add i + 1 node c1 m s k | c2 m s k split split split lineto add i + 1 node split i+1 move x1 y1 size != 0 illegal path state move allowed when empty add node x1 y1 line x1 y1 size == 0 illegal path state line allowed when empty add node x1 y1 quad x1 y1 x2 y2 size == 0 illegal path state quad allowed when empty add node c1 m s k x2 y2 x1 y1 x2 y2 curve x1 y1 x2 y2 x3 y3 size == 0 illegal path state curve allowed when empty node last point = get size 1 last point mask |= c2 m s k last point x 2 = x1 last point y 2 = y1 add node c1 m s k x3 y3 x2 y2 x3 y3 point2 d polygon point2 d points = point2 d size i=0 n = size i < n i++ points i = point2 d get i x 0 get i y 0 points 
/* * @ # geom 2 2 2006 07 04 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * ??? */package geom * geom * /** * some geometric utilities * * @version 2 2 2006 07 04 grow rectangle2 d added * <br>2 1 2006 01 20 support precision coordinates enhanced */public geom { geom {} never instantiated /** * tests a point is on a line */ line contains point x1 y1 x2 y2 px py { line contains point x1 y1 x2 y2 px py 3d } /** * tests a point is on a line * <p>changed werner randelshofer 2003 11 26 */ line contains point x1 y1 x2 y2 px py tolerance { rectangle r = rectangle point x1 y1 r add x2 y2 r grow math max 2 math ceil tolerance math max 2 math ceil tolerance ! r contains px py { } a b x y x1 == x2 { math abs px x1 <= tolerance } y1 == y2 { math abs py y1 <= tolerance } a = y1 y2 / x1 x2 b = y1 a * x1 x = py b / a y = a * px + b math min math abs x px math abs y py <= tolerance } /** * tests a point is on a line * <p>changed werner randelshofer 2003 11 26 */ line contains point x1 y1 x2 y2 px py tolerance { rectangle2 d r = rectangle2 d x1 y1 0 0 r add x2 y2 grow = math max 2 math ceil tolerance r x = grow r y = grow r width += grow * 2 r height += grow * 2 ! r contains px py { } a b x y x1 == x2 { math abs px x1 <= tolerance } y1 == y2 { math abs py y1 <= tolerance } a = y1 y2 / x1 x2 b = y1 a * x1 x = py b / a y = a * px + b math min math abs x px math abs y py <= tolerance } /** the bitmask that indicates that a point lies above the rectangle */ o u t t o p = rectangle2 d o u t t o p /** the bitmask that indicates that a point lies below the rectangle */ o u t b o t t o m = rectangle2 d o u t b o t t o m /** the bitmask that indicates that a point lies to the left of the rectangle */ o u t l e f t = rectangle2 d o u t l e f t /** the bitmask that indicates that a point lies to the right of the rectangle */ o u t r i g h t = rectangle2 d o u t r i g h t /** * the direction o u t t o p o u t b o t t o m o u t l e f t o u t r i g h t from * one point to another one */ direction x1 y1 x2 y2 { direction = 0 vx = x2 x1 vy = y2 y1 vy < vx vx > vy { direction = o u t r i g h t } vy > vx vy > vx { direction = o u t t o p } vx < vy vx < vy { direction = o u t l e f t } { direction = o u t b o t t o m } direction } /** * the direction o u t t o p o u t b o t t o m o u t l e f t o u t r i g h t from * one point to another one */ direction x1 y1 x2 y2 { direction = 0 vx = x2 x1 vy = y2 y1 vy < vx vx > vy { direction = o u t r i g h t } vy > vx vy > vx { direction = o u t t o p } vx < vy vx < vy { direction = o u t l e f t } { direction = o u t b o t t o m } direction } /** * computes a binary o r of the appropriate mask values * indicating each side of rectangle r1 whether or not the * rectangle r2 is on the same side of the edge as the rest * of rectangle * * * * * * * * * @return the logical o r of all appropriate out codes o u t r i g h t o u t l e f t o u t b o t t o m * o u t t o p */ outcode rectangle r1 rectangle r2 { outcode = 0 r2 x > r1 x + r1 width outcode = o u t r i g h t r2 x + r2 width < r1 x outcode = o u t l e f t r2 y > r1 y + r1 height outcode |= o u t b o t t o m r2 y + r2 height < r1 y outcode |= o u t t o p outcode } /** * computes a binary o r of the appropriate mask values * indicating each side of rectangle r1 whether or not the * rectangle r2 is on the same side of the edge as the rest * of rectangle * * * * * * * * * @return the logical o r of all appropriate out codes o u t r i g h t o u t l e f t o u t b o t t o m * o u t t o p */ outcode rectangle2 d r1 rectangle2 d r2 { outcode = 0 r2 x > r1 x + r1 width outcode = o u t r i g h t r2 x + r2 width < r1 x outcode = o u t l e f t r2 y > r1 y + r1 height outcode |= o u t b o t t o m r2 y + r2 height < r1 y outcode |= o u t t o p outcode } point south rectangle r { point r x + r width /2 r y + r height } point2 d south rectangle2 d r { point2 d r x + r width /2 r y + r height } point center rectangle r { point r x + r width /2 r y + r height/2 } point2 d center rectangle2 d r { point2 d r x + r width /2 r y + r height/2 } /** * a point on the edge of the bezier path which crosses the line * from the center of the bezier path to the specified point * no edge crosses the line the nearest c0 control point is */ point2 d chop shape shape point2 d p { rectangle2 d bounds = shape get bounds2 d point2 d ctr = point2 d bounds get center x bounds get center y chopped point cx = 1 cy = 1 len = m a x v a l u e points along edge path iterator i = shape get path iterator affine transform 1 coords = 6 type = i current segment coords prev x = coords 0 prev y = coords 1 move to x = prev x move to y = prev y i next ! i is done i next { i current segment coords { path iterator s e g m o v e t o move to x = coords 0 move to y = coords 1 path iterator s e g c l o s e coords 0 = move to x coords 1 = move to y } point2 d chop = geom intersect prev x prev y coords 0 coords 1 p x p y ctr x ctr y chop != { cl = geom length2 chop x chop y p x p y cl < len { len = cl cx = chop x cy = chop y } } prev x = coords 0 prev y = coords 1 } /* is closed size > 1 { node first = get 0 node last = get size 1 point2 d chop = geom intersect first x 0 first y 0 last x 0 last y 0 p x p y ctr x ctr y chop != { cl = geom length2 chop x chop y p x p y cl < len { len = cl cx = chop x cy = chop y } } }*/ none found pick closest vertex len == m a x v a l u e { i = shape get path iterator affine transform 1 ! i is done i next { i current segment coords l = geom length2 ctr x ctr y coords 0 coords 1 l < len { len = l cx = coords 0 cy = coords 1 } } } point2 d cx cy } point west rectangle r { point r x r y + r height/ 2 } point2 d west rectangle2 d r { point2 d r x r y + r height/ 2 } point east rectangle r { point r x+r width r y + r height/ 2 } point2 d east rectangle2 d r { point2 d r x+r width r y + r height/ 2 } point north rectangle r { point r x+r width/2 r y } point2 d north rectangle2 d r { point2 d r x+r width/2 r y } /** * constains a value to the given range * @return the constrained value */ range min max value { value < min { value = min } value > max { value = max } value } /** * constains a value to the given range * @return the constrained value */ range min max value { value < min { value = min } value > max { value = max } value } /** * gets the square distance between two points */ length2 x1 y1 x2 y2 { x2 x1 * x2 x1 + y2 y1 * y2 y1 } /** * gets the distance between to points */ length x1 y1 x2 y2 { math sqrt length2 x1 y1 x2 y2 } /** * gets the square distance between two points */ length2 x1 y1 x2 y2 { x2 x1 * x2 x1 + y2 y1 * y2 y1 } /** * gets the distance between to points */ length x1 y1 x2 y2 { math sqrt length2 x1 y1 x2 y2 } /** * gets the distance between to points */ length point2 d p1 point2 d p2 { math sqrt length2 p1 x p1 y p2 x p2 y } /** * caps the line defined by p1 and p2 by the number of units * specified by radius * @return a end point the line */ point2 d cap point2 d p1 point2 d p2 radius { angle = math p i/2 math atan2 p2 x p1 x p2 y p1 y point2 d p3 = point2 d p2 x + radius * math cos angle p2 y + radius * math sin angle p3 } /** * gets the angle of a point relative to a rectangle */ point to angle rectangle r point p { px = p x r x + r width/2 py = p y r y + r height/2 math atan2 py*r width px*r height } /** * gets the angle of a point relative to a rectangle */ point to angle rectangle2 d r point2 d p { px = p x r x + r width/2 py = p y r y + r height/2 math atan2 py*r width px*r height } /** * gets the angle of the specified line */ angle x1 y1 x2 y2 { math atan2 y2 y1 x2 x1 } /** * gets the point on a rectangle that corresponds to the given angle */ point angle to point rectangle r angle { si = math sin angle co = math cos angle e = 0 0001 x= 0 y= 0 math abs si > e { x= 1 0 + co/ math abs si /2 0 * r width x= range 0 r width x } co >= 0 0 { x= r width } math abs co > e { y= 1 0 + si/ math abs co /2 0 * r height y= range 0 r height y } si >= 0 0 { y= r height } point r x + x r y + y } /** * gets the point on a rectangle that corresponds to the given angle */ point2 d angle to point rectangle2 d r angle { si = math sin angle co = math cos angle e = 0 0001 x= 0 y = 0 math abs si > e { x= 1 0 + co/ math abs si /2 0 * r width x = range 0 r width x } co >= 0 0 { x = r width } math abs co > e { y = 1 0 + si/ math abs co /2 0 * r height y = range 0 r height y } si >= 0 0 { y = r height } point2 d r x + x r y + y } /** * converts a polar to a point */ point polar to point angle fx fy { si = math sin angle co = math cos angle point fx*co+0 5 fy*si+0 5 } /** * converts a polar to a point */ point2 d polar to point2 d angle fx fy { si = math sin angle co = math cos angle point2 d fx*co+0 5 fy*si+0 5 } /** * gets the point on an oval that corresponds to the given angle */ point oval angle to point rectangle r angle { point center = geom center r point p = geom polar to point angle r width/2 r height/2 point center x + p x center y + p y } /** * gets the point on an oval that corresponds to the given angle */ point2 d oval angle to point rectangle2 d r angle { point2 d center = geom center r point2 d p = geom polar to point2 d angle r width/2 r height/2 point2 d center x + p x center y + p y } /** * standard line intersection algorithm * the point of intersection it **/ from doug lea's polygon figure point intersect xa line 1 point 1 x ya line 1 point 1 y xb line 1 point 2 x yb line 1 point 2 y xc line 2 point 1 x yc line 2 point 1 y xd line 2 point 2 x yd { line 2 point 2 y source http vision dai ed ac uk/andrewfg/c g a faq html eq lines a b and c d y a y c x d x c x a x c y d y c r = eqn 1 x b x a y d y c y b y a x d x c y a y c x b x a x a x c y b y a s = eqn 2 x b x a y d y c y b y a x d x c x i = x a + r x b x a y i = y a + r y b y a denom = xb xa * yd yc yb ya * xd xc rnum = ya yc * xd xc xa xc * yd yc denom == 0 0 { parallel rnum == 0 0 { coincident pick one end of first line xa < xb xb < xc || xb < xd || xa > xb xb > xc || xb > xd { point xb yb } { point xa ya } } { } } r = rnum / denom snum = ya yc * xb xa xa xc * yb ya s = snum / denom 0 0 <= r r <= 1 0 0 0 <= s s <= 1 0 { px = xa + xb xa * r py = ya + yb ya * r point px py } { } } /** * standard line intersection algorithm * the point of intersection it **/ from doug lea's polygon figure point2 d intersect xa line 1 point 1 x ya line 1 point 1 y xb line 1 point 2 x yb line 1 point 2 y xc line 2 point 1 x yc line 2 point 1 y xd line 2 point 2 x yd { line 2 point 2 y source http vision dai ed ac uk/andrewfg/c g a faq html eq lines a b and c d y a y c x d x c x a x c y d y c r = eqn 1 x b x a y d y c y b y a x d x c y a y c x b x a x a x c y b y a s = eqn 2 x b x a y d y c y b y a x d x c x i = x a + r x b x a y i = y a + r y b y a denom = xb xa * yd yc yb ya * xd xc rnum = ya yc * xd xc xa xc * yd yc denom == 0 0 { parallel rnum == 0 0 { coincident pick one end of first line xa < xb xb < xc || xb < xd || xa > xb xb > xc || xb > xd { point2 d xb yb } { point2 d xa ya } } { } } r = rnum / denom snum = ya yc * xb xa xa xc * yb ya s = snum / denom 0 0 <= r r <= 1 0 0 0 <= s s <= 1 0 { px = xa + xb xa * r py = ya + yb ya * r point2 d px py } { } } point2 d intersect xa line 1 point 1 x ya line 1 point 1 y xb line 1 point 2 x yb line 1 point 2 y xc line 2 point 1 x yc line 2 point 1 y xd line 2 point 2 x yd limit { line 2 point 2 y source http vision dai ed ac uk/andrewfg/c g a faq html eq lines a b and c d y a y c x d x c x a x c y d y c r = eqn 1 x b x a y d y c y b y a x d x c y a y c x b x a x a x c y b y a s = eqn 2 x b x a y d y c y b y a x d x c x i = x a + r x b x a y i = y a + r y b y a denom = xb xa * yd yc yb ya * xd xc rnum = ya yc * xd xc xa xc * yd yc denom == 0 0 { parallel rnum == 0 0 { coincident pick one end of first line xa < xb xb < xc || xb < xd || xa > xb xb > xc || xb > xd { point2 d xb yb } { point2 d xa ya } } { } } r = rnum / denom snum = ya yc * xb xa xa xc * yb ya s = snum / denom 0 0 <= r r <= 1 0 0 0 <= s s <= 1 0 { px = xa + xb xa * r py = ya + yb ya * r point2 d px py } { px = xa + xb xa * r py = ya + yb ya * r length xa ya px py <= limit || length xb yb px py <= limit || length xc yc px py <= limit || length xd yd px py <= limit { point2 d px py } } } /** * compute distance of point from line segment or * m a x v a l u e perpendicular projection is outside segment or * pts on line are same distance from point **/ from doug lea's polygon figure distance from line xa ya xb yb xc yc { source http vision dai ed ac uk/andrewfg/c g a faq html#q7 let the point be c x c y c and the line be a b x a y a to x b y b the length of the line segment a b is l | 2 2 l = \| x b x a + y b y a and y a y c y a y b x a x c x b x a r = l**2 y a y c x b x a x a x c y b y a s = l**2 let i be the point of perpendicular projection of c onto a b the x i= x a+r x b x a y i= y a+r y b y a distance from a to i = r* l distance from c to i = s* l r < 0 i is on backward extension of a b r>1 i is on ahead extension of a b 0<=r<=1 i is on a b s < 0 c is left of a b you can just check the numerator s>0 c is right of a b s=0 c is on a b xdiff = xb xa ydiff = yb ya l2 = xdiff * xdiff + ydiff * ydiff l2 == 0 { geom length xa ya xc yc } rnum = ya yc * ya yb xa xc * xb xa r = rnum / l2 r < 0 0 || r > 1 0 { m a x v a l u e } xi = xa + r * xdiff yi = ya + r * ydiff xd = xc xi yd = yc yi math sqrt xd * xd + yd * yd /* directional instead use snum = ya yc * xb xa xa xc * yb ya s = snum / l2 l = math sqrt l2 = s * l */ } /** * resizes the <code> rectangle2 d double</code> both horizontally and vertically * <p> * modifies the <code> rectangle2 d double</code> so that it is * <code>h</code> units larger on both the left and right side * and <code>v</code> units larger at both the top and bottom * <p> * the <code> rectangle2 d double</code> has <code>x h</code> * <code>y v</code> as its top left corner a * width of * <code>width</code> <code>+</code> <code>2h</code> * and a height of * <code>height</code> <code>+</code> <code>2v</code> * <p> * negative values are supplied <code>h</code> and * <code>v</code> the size of the <code> rectangle2 d double</code> * decreases accordingly * the <code>grow</code> does not check whether the resulting * values of <code>width</code> and <code>height</code> are * non negative * @param h the horizontal expansion * @param v the vertical expansion */ grow rectangle2 d r h v { r x = h r y = v r width += h * 2d r height += v * 2d }} 
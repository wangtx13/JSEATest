/* * @ # bezier node handle 1 0 1 2006 04 21 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * */package draw * undo * * event * geom * * geom * /** * bezier node handle * * * @author werner randelshofer * @version 1 0 1 2006 04 21 don't change node type when right mouse button * is down * <br>1 0 january 20 2006 created */public bezier node handle handle { index composite edit edit bezier path node old node /** creates a instance */ bezier node handle bezier figure owner index { owner index = index } /** * draws handle */ draw graphics2 d g { bezier figure f = get bezier figure f get point count > index { bezier path node v = f get node index v mask == 0 { draw rectangle g color black color white } v mask == bezier path c1 m a s k || v mask == bezier path c2 m a s k || !f is closed v mask == bezier path c1 m a s k | bezier path c2 m a s k index == 0 || index == f get node count 1 { draw diamond g color black color white } { draw circle g color black color white } } } bezier figure get bezier figure { bezier figure get owner } point get location { get bezier figure get point count > index ? view drawing to view get bezier figure get point index 0 point 10 10 } rectangle basic get bounds { rectangle r = rectangle get location r grow get handlesize / 2 get handlesize / 2 r } track start point anchor modifiers ex { bezier figure figure = get bezier figure view get drawing fire undoable edit happened edit = composite edit punkt verschieben point2 d location = view get constrainer constrain point view view to drawing get location point2 d p = view get constrainer constrain point view view to drawing anchor old node = figure get node index fire handle request secondary handles } track step point anchor point modifiers ex { bezier figure figure = get bezier figure figure will change point2 d p = view get constrainer constrain point view view to drawing bezier path node n = figure get node index fire area invalidated n n move to p fire area invalidated n figure basic set node index n figure changed } fire area invalidated bezier path node v { rectangle2 d dr = rectangle2 d v x 0 v y 0 0 0 i=1 i < 3 i++ { dr add v x i v y i } rectangle vr = view drawing to view dr vr grow get handlesize get handlesize fire area invalidated vr } track end point anchor point modifiers ex { bezier figure f = get bezier figure change node type modifiers ex input event m e t a d o w n m a s k | input event c t r l d o w n m a s k != 0 modifiers ex input event b u t t o n2 d o w n m a s k == 0 { f will change bezier path node v = f get node index index > 0 index < f get node count || f is closed { v mask = v mask + 3 % 4 } index == 0 { v mask = v mask bezier path c2 m a s k == 0 ? bezier path c2 m a s k 0 } { v mask = v mask bezier path c1 m a s k == 0 ? bezier path c1 m a s k 0 } f basic set node index v f changed fire handle request secondary handles } view get drawing fire undoable edit happened bezier node edit f index old node f get node index view get drawing fire undoable edit happened edit } @ override is combinable with handle h { /* is combinable with h { bezier node handle that = bezier node handle h that index == index that get bezier figure get node count == get bezier figure get node count }*/ } track click point p modifiers ex { bezier figure f = get bezier figure f get node count > 2 modifiers ex input event m e t a d o w n m a s k | input event c t r l d o w n m a s k | input event a l t d o w n m a s k == 0 { rectangle invalidated area = get draw bounds f will change f basic remove node index f changed fire handle request remove invalidated area } } collection< handle> create secondary handles { bezier figure f = get bezier figure linked list< handle> list = linked list< handle> bezier path node v = f get node index v mask bezier path c1 m a s k != 0 index != 0 || f is closed { list add bezier control point handle f index 1 } v mask bezier path c2 m a s k != 0 index < f get node count 1 || f is closed { list add bezier control point handle f index 2 } index > 0 || f is closed { i = index == 0 ? f get node count 1 index 1 v = f get node i v mask bezier path c2 m a s k != 0 { list add bezier control point handle f i 2 } } index < f get node count 2 || f is closed { i = index == f get node count 1 ? 0 index + 1 v = f get node i v mask bezier path c1 m a s k != 0 { list add bezier control point handle f i 1 } } list }} 
/* * @ # generic listener 1 1 2003 11 03 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * */package draw action reflect * /** * the generic listener creates anonymous listener classes at runtime * <p> * usage * <pre> * demo { * j panel root = j panel border layout * j label label = j label * * my button action action event e { * label set text button action * } * * my mouse entered mouse event e { * label set text mouse entered +e to * } * * demo { * j button button = j button button with dynamic listener * * listener will be generated at run time i e at run time * an action listener will be generated and then * loaded only one of these is actually created even * many calls to generic listener create action listener * are made * action listener action listener = action listener generic listener create * action listener * action performed * * my button action * * button add action listener action listener * * here's another dynamically generated listener one is * a little different because the listener argument actually * specifies one of many listener in the previous example * action performed named the one and only action listener * mouse listener mouse listener = mouse listener generic listener create * mouse listener * mouse entered * * my mouse entered * * button add mouse listener mouse listener * </pre> * * @author werner randelshofer * @version 1 1 2003 11 03 support parameterless target added * <br>1 0 2003 11 02 created */public generic listener { /** * a convenient of <code>create listener target target </code> * looks up the listener and target so you don't have to */ create listener listener name target target name { listener = get listener listener listener name search a target with the same parameter types as the listener target = get target target target name listener get parameter types nothing found? search a target with no target == { target = get target target target name 0 } still nothing found? we give up target == { runtime no such +target name+ in +target get } create listener target target } /** * an instance of a that the that contains * the declaration <code>listener method</code> in * <code>listener method</code> will apply <code>target target method</code> * to the incoming event */ create listener target target { /** * the of the create uses the dynamic proxy a p i * introduced in j d k 1 3 * * create an instance of the invoker and override the * to handle the invoking the target on the target */ invocation handler handler = invoker { proxy throwable { send all except the target to the superclass handling listener equals { target get parameter types length == 0 { special treatment parameterless target target target 0 } { regular treatment target having the same argument list as the listener target target } } { proxy } } } cls = listener get declaring loader cl = cls get loader proxy proxy instance cl {cls} handler } /** * of the invocation handler which handles the basic * */ invoker invocation handler { proxy throwable { get declaring == { name = get name name equals hash { proxy hash proxy } name equals equals { proxy equals proxy 0 } name equals to { proxy to proxy } } although listener are supposed to be we allow any type here and produce null/0/false as appropriate value of get type } proxy hash proxy { identity hash proxy } proxy equals proxy other { proxy == other ? t r u e f a l s e } proxy to proxy { proxy get get name + '@' + to hex proxy hash } character 0 = character 0 0 = 0 value of rt { !rt is primitive { } rt == { } rt == { f a l s e } rt == { 0 } { will convert to any other kind of number 0 } } } /* helper e z of create */ get listener listener listener name { given the arguments to create find out which listener is desired m = listener get result = i = 0 i < m length i++ { listener name equals m i get name { result != { runtime ambiguous +m i + vs +result } result = m i } } result == { runtime no such +listener name+ in +listener } result } get target target target name parameter types { m = target get get result = each i = 0 i < m length i++ { !target name equals m i get name each p = m i get parameter types p length != parameter types length each j = 0 j < p length j++ { !p j is assignable from parameter types j each } result != { runtime ambiguous +m i + vs +result } result = m i } /* result == { runtime no such +target name+ in +target get }*/ result == { } result = raise to result result != result = result result } raise to m { c = m get declaring modifier is m get modifiers modifier is c get modifiers m yes! search a which m sc = c get superclass sc != { sm = raise to m sc sm != sm } ints = c get i = 0 i < ints length i++ { im = raise to m ints i im != im } no of m here } raise to m c { { sm = c get m get name m get parameter types raise to sm } no such ee { } } generic listener {}} 
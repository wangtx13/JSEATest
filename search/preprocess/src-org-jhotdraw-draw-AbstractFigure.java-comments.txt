/* * @ # figure 3 3 2006 06 17 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * */package draw * event * * event * font * geom * * * undo * io * geom * /** * figure provides the functionality managing listeners * a figure * * @author werner randelshofer * @version 3 3 reworked * <br>3 2 2006 01 05 added get changing depth * <br>3 0 2006 01 20 reworked j2 s e 1 5 * <br>1 0 2003 12 01 derived from 5 4b1 */public figure figure { event listener list listener list = event listener list is connectors visible connection figure courting connection drawing drawing is interactive is visible = figure decorator is draw decorator first = /** * we increase number on each invocation of will change and * decrease it on each invocation of changed */ changing depth = 0 /** creates a instance */ figure { } d r a w i n g s h a p e a n d b o u n d s a t t r i b u t e s e d i t i n g c o n n e c t i n g c o m p o s i t e f i g u r e s c l o n i n g e v e n t h a n d l i n g add figure listener figure listener l { listener list add figure listener l } remove figure listener figure listener l { listener list remove figure listener l } add undoable edit listener undoable edit listener l { listener list add undoable edit listener l } remove undoable edit listener undoable edit listener l { listener list remove undoable edit listener l } add notify drawing d { drawing = d fire figure added } remove notify drawing d { fire figure removed drawing = } drawing get drawing { drawing } get lock { get drawing == ? get drawing get lock } set draw decorator first value { is draw decorator first = value } is draw decorator first { is draw decorator first } /** * notify all listener list that have registered interest * notification on event type */ fire area invalidated { fire area invalidated get draw bounds } /** * notify all listener list that have registered interest * notification on event type */ fire area invalidated rectangle2 d invalidated area { listener list get listener count > 0 { figure event event = notify all listeners that have registered interest guaranteed to a non listeners = listener list get listener list process the listeners last to first notifying those that are interested in event i = listeners length 2 i>=0 i =2 { listeners i == figure listener { lazily create the event event == event = figure event invalidated area figure listener listeners i+1 figure area invalidated event } } } } /** * notify all listener list that have registered interest * notification on event type */ fire figure request remove { listener list get listener count > 0 { figure event event = notify all listeners that have registered interest guaranteed to a non listeners = listener list get listener list process the listeners last to first notifying those that are interested in event i = listeners length 2 i>=0 i =2 { listeners i == figure listener { lazily create the event event == event = figure event get bounds figure listener listeners i+1 figure request remove event } } } } /** * notify all listener list that have registered interest * notification on event type */ fire figure added { listener list get listener count > 0 { figure event event = notify all listeners that have registered interest guaranteed to a non listeners = listener list get listener list process the listeners last to first notifying those that are interested in event i = listeners length 2 i>=0 i =2 { listeners i == figure listener { lazily create the event event == event = figure event get bounds figure listener listeners i+1 figure added event } } } } /** * notify all listener list that have registered interest * notification on event type */ fire figure removed { listener list get listener count > 0 { figure event event = notify all listeners that have registered interest guaranteed to a non listeners = listener list get listener list process the listeners last to first notifying those that are interested in event i = listeners length 2 i>=0 i =2 { listeners i == figure listener { lazily create the event event == event = figure event get bounds figure listener listeners i+1 figure removed event } } } } fire figure changed { fire figure changed get bounds } /** * notify all listener list that have registered interest * notification on event type */ fire figure changed rectangle2 d changed area { listener list get listener count > 0 { figure event event = notify all listeners that have registered interest guaranteed to a non listeners = listener list get listener list process the listeners last to first notifying those that are interested in event i = listeners length 2 i>=0 i =2 { listeners i == figure listener { lazily create the event event == event = figure event changed area figure listener listeners i+1 figure changed event } } } } fire figure changed figure event event { listener list get listener count > 0 { notify all listeners that have registered interest guaranteed to a non listeners = listener list get listener list process the listeners last to first notifying those that are interested in event i = listeners length 2 i>=0 i =2 { listeners i == figure listener { lazily create the event figure listener listeners i+1 figure changed event } } } } /** * notify all listener list that have registered interest * notification on event type */ fire attribute changed attribute key attribute old value value { listener list get listener count > 0 { figure event event = notify all listeners that have registered interest guaranteed to a non listeners = listener list get listener list process the listeners last to first notifying those that are interested in event i = listeners length 2 i>=0 i =2 { listeners i == figure listener { lazily create the event event == event = figure event attribute old value value figure listener listeners i+1 figure attribute changed event } } } } /** * notify all listener list that have registered interest * notification on event type */ fire undoable edit happened undoable edit edit { undoable edit event event = listener list get listener count > 0 { notify all listeners that have registered interest guaranteed to a non listeners = listener list get listener list process the listeners last to first notifying those that are interested in event i = listeners length 2 i>=0 i =2 { event == event = undoable edit event edit listeners i == undoable edit listener { undoable edit listener listeners i+1 undoable edit happened event } } } } /* set create handles { hash set } */ figure clone { { figure that = figure clone that listener list = event listener list that is connectors visible = that courting connection = decorator != { that decorator = figure decorator clone } that } clone not supported e { internal = internal e get message init cause e } } figure basic clone hash map< figure figure> old to { x x x delete me } remap hash map< figure figure> old to { } collection< handle> create handles detail level { linked list< handle> handles = linked list< handle> detail level == 0 { box handle kit add box handles handles } handles } cursor get cursor point2 d p { contains p { cursor get predefined cursor cursor h a n d c u r s o r } { cursor get cursor } } set bounds rectangle2 d bounds { set bounds point2 d bounds x bounds y point2 d bounds x + bounds width bounds y + bounds height } set bounds point2 d anchor point2 d { point2 d old anchor = get start point point2 d old = get end point ! old anchor equals anchor || ! old equals { will change basic set bounds anchor changed fire undoable edit happened set bounds edit old anchor old anchor } } /** * checks figure can be connected by * figures can be connected */ can connect { } /** * informs that a figure needs to be redrawn */ invalidate { fire area invalidated get draw bounds } is changing { changing depth != 0 } get changing depth { changing depth } /** * informs that a figure is about to change something that * affects the contents of its display box */ will change { changing depth++ invalidate } validate { } /** * informs that a figure changed the area of its display box */ changed { changing depth <= 1 { validate fire figure changed get draw bounds changing depth = 0 } { changing depth } } /** * transforms the geometry of the figure */ transform affine transform tx { will change basic transform tx fire undoable edit happened transform edit tx changed } /** * moves the figure is the * that subclasses override * <p> * is a basic operation which no events are fired */ basic transform affine transform ty /** * the figures connector the specified location * by a chop box connector is * * * @see chop box connector */ connector find connector point2 d p connection figure prototype { chop box connector } includes figure figure { figure == } figure find figure inside point2 d p { contains p ? } connector find compatible connector connector c is start { chop box connector } /** * a collection of actions which are presented to the user * in a popup menu * <p> the collection may contain entries these entries are used * interpreted as separators in the popup menu */ collection< action> get actions point2 d p { collections empty list } /** * a specialized tool the given coordinate * <p> no specialized tool is available */ tool get tool point2 d p { } /** * handles a mouse click */ handle mouse click point2 d p mouse event evt drawing view view { } handle drop point2 d p collection< figure> dropped figures drawing view view { } point2 d get end point { rectangle2 d r = get bounds point2 d r x + r width r y + r height } point2 d get start point { rectangle2 d r = get bounds point2 d r x r y } /* rectangle2 d get hit bounds { get bounds } */ dimension2 d get preferred size { rectangle2 d r = get bounds dimension2 d r width r height } remap map old to { } is interactive { is interactive } set interactive b { is interactive = b } is visible { is visible } set visible value { value != is visible { will change is visible = value changed } } set connectors visible is visible connection figure connection { will change is connectors visible = is visible courting connection = connection changed } is connectors visible { is connectors visible } connection figure get courting connection { courting connection } collection< figure> get decomposition { linked list< figure> list = linked list< figure> list add list } font render context get font render context { font render context frc = frc == { frc = font render context affine transform options is text antialiased options is fractional metrics } frc } request remove { fire figure request remove } get layer { 0 } get tooltip point2 d p { } set decorator figure value { will change decorator = value decorator != { decorator basic set bounds get start point get end point } changed } figure get decorator { decorator } draw graphics2 d g { is draw decorator first { draw decorator g draw figure g } { draw figure g draw decorator g } } draw figure graphics2 d g draw decorator graphics2 d g { decorator != { update decorator bounds decorator draw g } } update decorator bounds { decorator != { point2 d sp = get start point point2 d ep = get end point insets2 d decorator insets = attribute keys d e c o r a t o r i n s e t s get sp x = decorator insets left sp y = decorator insets top ep x += decorator insets right ep y += decorator insets bottom decorator basic set bounds sp ep } } rectangle2 d get draw bounds { rectangle2 d figure draw bounds = get figure draw bounds decorator != { update decorator bounds figure draw bounds add decorator get draw bounds } figure draw bounds } rectangle2 d get figure draw bounds to { builder buf = builder buf append get get name substring get get name last index of ' ' +1 buf append '@' buf append hash buf to }} 
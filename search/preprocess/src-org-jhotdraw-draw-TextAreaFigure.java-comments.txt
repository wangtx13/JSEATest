/* * @ # text area figure 2 0 1 2006 02 27 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * ??? */package draw * * font * geom * text * * io * draw attribute keys * geom * xml dom input xml dom output /** * a text area figure contains formatted text <br> * it automatically rearranges the text to fit its allocated display area * breaking the lines at word boundaries whenever possible <br> * the text can contain either l f or c r l f sequences to separate paragraphs * as well as tab characters table like formatting and alignment <br> * currently the tabs are distributed at regular intervals as determined by * the tab size property tabs align correctly with either fixed * or variable fonts <br> * when resizing the vertical size of the display box is not enough to * display all the text text area figure displays a dashed red line at the * bottom of the figure to indicate there is hidden text <br> * text are figure uses all standard attributes the area rectangle2 d * ie fill color pen color the border font size font style and font name * as well as four additional attributes left margin right margin top margin * and tab size <br> * <p> * x x x text area figure should not draw a rectangle on its own but rather * rely on a decorator we probably need a decorator connector and we * need a way to specify the inner bounds of the decorator we also need a way * to center the text of the text area figure verticaly and horizontaly * * @author eduardo francos in context original * werner randelshofer derived * @version 2 0 1 2006 02 27 draw u n d e r l i n e l o w o n e p i x e l instead of u n d e r l i n e o n * <br>2 0 2006 01 14 changed to support coordinates * <br>1 0 5 m???rz 2004 created */public text area figure attributed figure text holder { rectangle2 d bounds = rectangle2 d editable = basic stroke dashes = basic stroke 1f basic stroke c a p b u t t basic stroke j o i n b e v e l 0f {4f 4f} 0f cache of the text figure's layout text layout text layout /** creates a instance */ text area figure { text } text area figure text { set text text } /** * gets the text shown by the text figure */ get text { get attribute t e x t } /** * sets the text shown by the text figure */ set text text { set attribute t e x t text } basic set bounds point2 d anchor point2 d { bounds x = math min anchor x x bounds y = math min anchor y y bounds width = math max 1 math abs x anchor x bounds height = math max 1 math abs y anchor y text layout = } basic transform affine transform tx { point2 d anchor = get start point point2 d = get end point basic set bounds point2 d tx transform anchor anchor point2 d tx transform } contains point2 d p { bounds contains p } /** * the insets used to draw text */ insets2 d get insets { sw = math ceil s t r o k e w t h get / 2 insets2 d insets = insets2 d 4 4 4 4 insets2 d insets top+sw insets left+sw insets bottom+sw insets right+sw } get tab size { 8 } draw text graphics2 d g { get text != || is editable { font font = get font is underlined = f o n t u n d e r l i n e d get insets2 d insets = get insets rectangle2 d text rect = rectangle2 d bounds x + insets left bounds y + insets top bounds width insets left insets right bounds height insets top insets bottom left margin = text rect x right margin = math max left margin + 1 text rect x + text rect width vertical pos = text rect y left margin < right margin { tab width = get tab size * g get font metrics font width 'm' tab stops = text rect width / tab width i=0 i < tab stops length i++ { tab stops i = text rect x + tab width * i + 1 } get text != { shape saved clip area = g get clip g clip text rect paragraphs = get text split \n strings split get text '\n' i = 0 i < paragraphs length i++ { paragraphs i length == 0 paragraphs i = attributed as = attributed paragraphs i as add attribute text attribute f o n t font is underlined { as add attribute text attribute u n d e r l i n e text attribute u n d e r l i n e l o w o n e p i x e l } tab count = tokenizer paragraphs i \t count tokens 1 vertical pos = draw paragraph g as get iterator vertical pos left margin right margin tab stops tab count vertical pos > text rect y + text rect height { } } g set clip saved clip area } } left margin >= right margin || vertical pos > text rect y + text rect height { g set color color red g set stroke dashes g draw line2 d text rect x text rect y + text rect height 1 text rect x + text rect width 1 text rect y + text rect height 1 } } } /** * draws a paragraph of text at the specified y location and * the y position the next paragraph */ draw paragraph graphics2 d g attributed character iterator styled text vertical pos left margin right margin tab stops tab count { assume styled text is an attributed character iterator and the number of tabs in styled text is tab count tab locations = tab count+1 i = 0 c = styled text first c != styled text d o n e c = styled text next { c == '\t' { tab locations i++ = styled text get index } } tab locations tab count = styled text get end index 1 now tab locations has an entry every tab's offset in the text convenience the last entry is tab locations is the offset of the last character in the text line measurer measurer = line measurer styled text get font render context current tab = 0 measurer get position < styled text get end index { lay out and draw each line all segments on a line must be computed before any drawing can occur since we must know the largest ascent on the line text layouts are computed and stored in a list their horizontal positions are stored in a parallel list line contains text is after first segment is drawn line contains text = line complete = max ascent = 0 max descent = 0 horizontal pos = left margin linked list< text layout> layouts = linked list< text layout> linked list< float> pen positions = linked list< float> !line complete { wrapping width = right margin horizontal pos text layout layout = layout = measurer next layout wrapping width tab locations current tab +1 line contains text layout can be line contains text is layout != { layouts add layout pen positions add horizontal pos horizontal pos += layout get advance max ascent = math max max ascent layout get ascent max descent = math max max descent layout get descent + layout get leading } { line complete = } line contains text = measurer get position == tab locations current tab +1 { current tab++ } measurer get position == styled text get end index line complete = tab stops length == 0 || horizontal pos >= tab stops tab stops length 1 line complete = !line complete { move to next tab stop j j=0 horizontal pos >= tab stops j j++ {} horizontal pos = tab stops j } } vertical pos += max ascent iterator< text layout> layout = layouts iterator iterator< float> position = pen positions iterator now iterate through layouts and draw them layout has next { text layout next layout = layout next next position = position next next layout draw g next position vertical pos } vertical pos += max descent } vertical pos } draw fill graphics2 d g { g fill bounds } draw stroke graphics2 d g { g draw bounds } rectangle2 d get bounds { rectangle2 d bounds get bounds2 d } collection< handle> create handles detail level { linked list< handle> handles = linked list< handle> create handles detail level detail level == 0 { handles add font size handle } handles } validate { validate text layout = } is editable { editable } set editable b { editable = b } get text columns { get text == ? 4 math max get text length 4 } /** * a specialized tool the given coordinate * <p> no specialized tool is available */ tool get tool point2 d p { is editable contains p ? text area tool } read bounds dom input in i o { bounds x = in get attribute x 0d bounds y = in get attribute y 0d bounds width = in get attribute w 0d bounds height = in get attribute h 0d } write bounds dom output out i o { out add attribute x bounds x out add attribute y bounds y out add attribute w bounds width out add attribute h bounds height } read dom input in i o { read bounds in read attributes in text layout = } write dom output out i o { write bounds out write attributes out } text area figure clone { text area figure that = text area figure clone that bounds = rectangle2 d bounds clone that } text holder get label { } restore to geometry { rectangle2 d r = rectangle2 d geometry bounds x = r x bounds y = r y bounds width = r width bounds height = r height } get restore data { bounds clone } font get font { attribute keys get font } color get text color { t e x t c o l o r get } color get fill color { f i l l c o l o r get } set font size size { f o n t s i z e set size } get font size { f o n t s i z e get value }} 
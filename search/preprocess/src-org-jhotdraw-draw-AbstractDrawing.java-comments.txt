/* * @ # drawing 2 1 2006 07 08 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * ??? */package draw beans * undo * xml * * geom * font * * event * undo * * * io * /** * drawing * * @author werner randelshofer * @version 2 1 2006 07 08 extend bean * <br>2 0 1 2006 02 06 did ugly dirty fix index out of bounds when * undoing removal of figures * <br>2 0 2006 01 14 changed to support precision coordinates * <br>1 0 2003 12 01 derived from 5 4b1 */public drawing bean drawing { lock = j panel get tree lock event listener list listener list = event listener list font render context font render context /** creates a instance */ drawing { } add drawing listener drawing listener listener { listener list add drawing listener listener } remove drawing listener drawing listener listener { listener list remove drawing listener listener } add undoable edit listener undoable edit listener l { listener list add undoable edit listener l } remove undoable edit listener undoable edit listener l { listener list remove undoable edit listener l } add all collection< figure> figures { composite edit edit = composite edit figuren hinzuf\u00fcgen fire undoable edit happened edit figure f figures { add f } fire undoable edit happened edit } /*** * removes all figures */ clear { remove all get figures } /** * gets the number of figures */ get figure count { get figures size } remove all collection< figure> to be removed { composite edit edit = composite edit figuren entfernen fire undoable edit happened edit figure f list< figure> to be removed { remove f } fire undoable edit happened edit } basic add all collection< figure> figures { figure f figures { basic add f } } basic remove all collection< figure> to be orphaned { note we create a collection to avoid problems that may be caused the collection is somehow connected to our figures connection figure f list< figure> to be orphaned { basic remove f } } /** * calls basic add and then calls figure add notify and fires figure added */ add figure figure { index = get figure count basic add index figure figure add notify fire figure added figure fire undoable edit happened undoable edit { get presentation name { figur einf\u00fcgen } undo cannot undo { undo basic remove figure figure remove notify drawing fire figure removed figure } redo cannot undo { redo basic add index figure figure add notify drawing fire figure added figure } } } basic add figure figure { basic add get figure count figure } /** * calls basic remove and then calls figure add notify and fires figure added */ remove figure figure { contains figure { index = index of figure basic remove figure figure remove notify fire figure removed figure fire undoable edit happened undoable edit { get presentation name { figur entfernen } redo cannot undo { redo basic remove figure figure remove notify drawing fire figure removed figure } undo cannot undo { undo basic add index figure figure add notify drawing fire figure added figure } } } { fire area invalidated figure get draw bounds } } index of figure figure /** * notify all listener list that have registered interest * notification on event type */ fire area invalidated rectangle2 d dirty region { drawing event event = notify all listeners that have registered interest guaranteed to a non listeners = listener list get listener list process the listeners last to first notifying those that are interested in event i = listeners length 2 i>=0 i =2 { listeners i == drawing listener { lazily create the event event == event = drawing event dirty region drawing listener listeners i+1 area invalidated event } } } /** * notify all listener list that have registered interest * notification on event type */ fire undoable edit happened undoable edit edit { undoable edit event event = listener list get listener count > 0 { notify all listeners that have registered interest guaranteed to a non listeners = listener list get listener list process the listeners last to first notifying those that are interested in event i = listeners length 2 i>=0 i =2 { event == event = undoable edit event edit listeners i == undoable edit listener { undoable edit listener listeners i+1 undoable edit happened event } } } } /** * notify all listener list that have registered interest * notification on event type */ fire figure added figure f { drawing event event = notify all listeners that have registered interest guaranteed to a non listeners = listener list get listener list process the listeners last to first notifying those that are interested in event i = listeners length 2 i>=0 i =2 { listeners i == drawing listener { lazily create the event event == event = drawing event f f get draw bounds drawing listener listeners i+1 figure added event } } } /** * notify all listener list that have registered interest * notification on event type */ fire figure removed figure f { drawing event event = notify all listeners that have registered interest guaranteed to a non listeners = listener list get listener list process the listeners last to first notifying those that are interested in event i = listeners length 2 i>=0 i =2 { listeners i == drawing listener { lazily create the event event == event = drawing event f f get draw bounds drawing listener listeners i+1 figure removed event } } } font render context get font render context { font render context } set font render context font render context frc { font render context = frc } read dom input in i o { in open element figures i=0 i < in get element count i++ { figure f add f = figure in read i } in close element } write dom output out i o { out open element figures figure f get figures { out write f } out close element } /** * the drawing view synchronizes on the lock when drawing a drawing */ get lock { lock }} 
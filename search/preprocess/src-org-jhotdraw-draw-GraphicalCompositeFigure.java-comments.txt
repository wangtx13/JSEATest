/* * @ # graphical composite figure 2 0 2006 01 14 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * ??? */package draw io i o * * geom * * undo * event * draw attribute keys * geom * xml dom input xml dom output /** * the graphical composite figure fills in the gap between a composite figure * and other figures which mainly have a presentation purpose the * graphical composite figure can be configured with any figure which * takes over the task rendering the graphical presentation * a composite figure therefore the graphical composite figure manages * contained figures like the composite figure does but delegates * its graphical presentation to another graphical figure which * purpose it is to draw the container all contained figures * * the graphical composite figure adds to the {@link composite figure composite figure} * by containing a presentation figure by which can not be removed normally * the {@link composite figure composite figure} can not be seen without containing a figure * because it has no mechanism to draw itself it instead relies on its contained * figures to draw themselves thereby giving the {@link composite figure composite figure} its * appearance however the <b> graphical composite figure</b>'s presentation figure * can draw itself even when the <b> graphical composite figure</b> contains no other figures * the <b> graphical composite figure</b> also uses a {@link layouter layouter} or layout * its contained figures * * * * @author wolfram kaiser original werner randelshofer derived * @version 2 0 2006 01 14 changed to support precision coordinates * <br>1 0 1 dezember 2003 derived from 5 4b1 */public graphical composite figure composite figure { hash map< attribute key object> attributes = hash map< attribute key object> hash set< attribute key> forbidden attributes /** * figure which performs all presentation tasks * composite figure as composite figures usually don't have * an own presentation but present only the sum of all its * children */ figure presentation figure /** * handles figure changes in the children */ presentation figure handler presentation figure handler = presentation figure handler presentation figure handler figure listener undoable edit listener { graphical composite figure owner presentation figure handler graphical composite figure owner { owner = owner } figure request remove figure event e { owner remove e get figure } figure removed figure event evt { } figure changed figure event e { ! owner is changing { owner will change owner fire figure changed e owner changed } } figure added figure event e { } figure attribute changed figure event e { } figure area invalidated figure event e { ! owner is changing { owner fire area invalidated e get invalidated area } } undoable edit happened undoable edit event e { owner fire undoable edit happened e get edit } } /** * constructor which uses nothing as presentation * figure constructor is needed by the storable mechanism */ graphical composite figure { } /** * constructor which creates a graphical composite figure with * a given graphical figure presenting it * * @param	new presentation figure	figure which renders the container */ graphical composite figure figure presentation figure { set presentation figure presentation figure } /** * the logcal display area is delegated to the encapsulated * presentation figure */ rectangle2 d get bounds { get presentation figure == get bounds get presentation figure get bounds } contains point2 d p { get presentation figure != { get presentation figure contains p } { contains p } } add notify drawing drawing { add notify drawing get presentation figure != { get presentation figure add notify drawing } } remove notify drawing drawing { remove notify drawing get presentation figure != { get presentation figure remove notify drawing } } /** * the draw area is delegated to the * encapsulated presentation figure */ rectangle2 d get figure draw bounds { rectangle2 d r get presentation figure != { rectangle2 d presentation bounds = get presentation figure get draw bounds r = get figure draw bounds r is empty { r = presentation bounds } { r add presentation bounds } } { r = get figure draw bounds } r } /** * moves the figure is the * that subclassers override clients usually * call display box */ basic set bounds point2 d anchor point2 d { get layouter == { basic set bounds anchor basic set presentation figure bounds anchor } { rectangle2 d r = get layouter layout anchor basic set presentation figure bounds point2 d r get x r get y point2 d math max x r get max x math max y r get max y invalidate } } basic set bounds point2 d anchor point2 d { basic set bounds anchor } basic set presentation figure bounds point2 d anchor point2 d { get presentation figure != { get presentation figure basic set bounds anchor } } /** * standard presentation which is delegated to the encapsulated presentation figure * the presentation figure is moved as well as all contained figures */ basic transform affine transform tx { basic transform tx get presentation figure != { get presentation figure basic transform tx } } /** * draw the figure is delegated to the encapsulated presentation figure */ draw figure graphics2 d g { draw presentation figure g draw figure g } draw presentation figure graphics2 d g { get presentation figure != { get presentation figure draw g } } /** * handles from the presentation figure */ collection< handle> create handles detail level { linked list< handle> handles = linked list< handle> detail level == 0 { move handle add move handles handles } handles get presentation figure get handles } /** * set a figure which renders composite figure the presentation * tasks the composite figure are delegated to presentation * figure * * * @param presentation figure	figure takes over the presentation tasks */ set presentation figure figure presentation figure { presentation figure != { presentation figure remove figure listener presentation figure handler presentation figure remove undoable edit listener presentation figure handler get drawing != { presentation figure remove notify get drawing } } presentation figure = presentation figure presentation figure != { presentation figure add figure listener presentation figure handler presentation figure add undoable edit listener presentation figure handler get drawing != { presentation figure add notify get drawing } } f i x m e we should calculate the layout here } /** * get a figure which renders composite figure the presentation * tasks the composite figure are delegated to presentation * figure * * * @return figure takes over the presentation tasks */ figure get presentation figure { presentation figure } graphical composite figure clone { graphical composite figure that = graphical composite figure clone that presentation figure = presentation figure == ? figure presentation figure clone that presentation figure != { that presentation figure add figure listener that presentation figure handler that presentation figure add undoable edit listener that presentation figure handler } that } remap hash map< figure figure> old to { remap old to presentation figure != { presentation figure remap old to } } /** * sets an attribute of the figure * attribute key name and semantics are defined by the implementing * the figure */ set attribute attribute key key value { forbidden attributes == || ! forbidden attributes contains key { will change get presentation figure != { get presentation figure set attribute key value } set attribute key value old value = attributes put key value fire attribute changed key old value value fire undoable edit happened attribute change edit key old value value changed } } /** * sets an attribute of the figure * attribute key name and semantics are defined by the implementing * the figure */ basic set attribute attribute key key value { forbidden attributes == || ! forbidden attributes contains key { get presentation figure != { get presentation figure basic set attribute key value } basic set attribute key value old value = attributes put key value } } set attribute enabled attribute key key b { forbidden attributes == { forbidden attributes = hash set< attribute key> } b { forbidden attributes remove key } { forbidden attributes add key } } /** * gets an attribute from the figure */ get attribute attribute key key { get presentation figure != { get presentation figure get attribute key } { ! attributes contains key key ? key get value attributes get key } } /** * applies all attributes of figure to that figure */ apply attributes to figure that { map entry< attribute key object> entry attributes entry set { that set attribute entry get key entry get value } } write attributes dom output out i o { figure prototype = figure out get prototype is element open = map entry< attribute key object> entry attributes entry set { attribute key key = entry get key forbidden attributes == || ! forbidden attributes contains key { prototype value = key get prototype attribute value = key get prototype value != attribute value || prototype value != attribute value != ! prototype value equals attribute value { ! is element open { out open element a is element open = } out open element key get key out write entry get value out close element } } } is element open { out close element } } read attributes dom input in i o { in get element count a > 0 { in open element a i=in get element count 1 i >= 0 i { in open element i name = in get tag name value = in read attribute key key = get attribute key name key != key is assignable value { forbidden attributes == || ! forbidden attributes contains key { set attribute key value } } in close element } in close element } } attribute key get attribute key name { attribute keys supported attribute map get name } map< attribute key object> get attributes { hash map< attribute key object> attributes } /** * is a that chops the point at the rectangle * by get bounds of the figure * <p> * figures which have a non rectangular shape need to override * <p> * takes the following attributes into account * attribute keys s t r o k e c o l o r attribute keys s t r o k e p l a c e m e n t and * attribute keys stroke total width */ point2 d chop point2 d from { rectangle2 d r = get bounds s t r o k e c o l o r get != { grow s t r o k e p l a c e m e n t get { c e n t e r grow = attribute keys get stroke total width o u t s e grow = attribute keys get stroke total width i n s e grow = 0d } geom grow r grow grow } geom angle to point r geom point to angle r from }} 
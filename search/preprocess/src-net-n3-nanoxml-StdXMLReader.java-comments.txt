/* std xml reader nano xml/ * * $ revision 1 4 $ * $ date 2002/01/04 21 03 28 $ * $ name r e l e a s e 2 2 1 $ * * is part of nano xml 2 * copyright c 2000 2002 marc de scheemaecker all rights reserved * * software is provided 'as is' without any express or implied warranty * in no event will the authors be held liable any damages arising from the * use of software * * permission is granted to anyone to use software any purpose * including commercial applications and to alter it and redistribute it * freely subject to the following restrictions * * 1 the origin of software must not be misrepresented you must not * claim that you wrote the original software you use software in * a product an acknowledgment in the product documentation would be * appreciated but is not required * * 2 altered source versions must be plainly marked as such and must not be * misrepresented as being the original software * * 3 notice may not be removed or altered from any source distribution */package net n3 nanoxml io input stream io input stream reader io i o io io input stream io not found io line number reader io pushback reader io pushback input stream io reader io reader io unsupported encoding net malformed u r l net u r l stack /** * std xml reader reads the data to be parsed * * @author marc de scheemaecker * @version $ name r e l e a s e 2 2 1 $ $ revision 1 4 $ */public std xml reader i xml reader{ /** * a stacked reader * * @author marc de scheemaecker * @version $ name r e l e a s e 2 2 1 $ $ revision 1 4 $ */ stacked reader { pushback reader pb reader line number reader line reader u r l } /** * the stack of readers */ stack readers /** * the current push back reader */ stacked reader current reader /** * creates a reader using a as input * * @param str the containing the xml data */ i xml reader reader str { std xml reader reader str } /** * creates a reader using a as input * * @param filename the name of the containing the xml data * * @throws io not found * the could not be found * @throws io i o * an i/ o occurred */ i xml reader reader filename not found i o { std xml reader r = std xml reader input stream filename r set filename i = 0 i < r readers size i++ { stacked reader sr = stacked reader r readers element at i sr = r current reader } r } /** * initializes the reader from a and * * @param the which may be * @param the non * * @throws malformed u r l * the does not contain a valid u r l * @throws not found * the refers to a local which does not * @throws i o * an occurred opening the stream */ std xml reader malformed u r l not found i o { u r l idas u r l = { idas u r l = u r l } malformed u r l e { = + { idas u r l = u r l } malformed u r l e2 { e } } current reader = stacked reader readers = stack reader reader = open stream idas u r l to current reader line reader = line number reader reader current reader pb reader = pushback reader current reader line reader 2 } /** * initializes the xml reader * * @param reader the input the xml data */ std xml reader reader reader { current reader = stacked reader readers = stack current reader line reader = line number reader reader current reader pb reader = pushback reader current reader line reader 2 current reader = { current reader = u r l } malformed u r l e { never happens } } /** * cleans up the when it's destroyed */ finalize throwable { current reader line reader = current reader pb reader = current reader = current reader = current reader = readers clear finalize } /** * scans the encoding from an lt ?xml ? tag * * @param str the first tag in the xml data * * @return the encoding or no encoding has been specified */ get encoding str { ! str starts with <?xml { } index = 5 index < str length { buffer key = buffer index < str length str at index <= ' ' { index++ } index < str length str at index >= 'a' str at index <= 'z' { key append str at index index++ } index < str length str at index <= ' ' { index++ } index >= str length || str at index != '=' { } index < str length str at index != '\'' str at index != ' ' { index++ } index >= str length { } delimiter = str at index index++ index2 = str index of delimiter index index2 < 0 { } key to equals encoding { str substring index index2 } index = index2 + 1 } } /** * converts a stream to a reader detecting the encoding * * @param stream the input the xml data * @param chars read buffer where to put characters that have been read * * @throws io i o * an i/ o occurred */ reader stream2reader input stream stream buffer chars read i o { pushback input stream pbstream = pushback input stream stream b = pbstream read b { 0x00 0x f e 0x f f pbstream unread b input stream reader pbstream u t f 16 0x e f i = 0 i < 2 i++ { pbstream read } input stream reader pbstream u t f 8 0x3 c b = pbstream read chars read append '<' b > 0 b != 0x3 e { chars read append b b = pbstream read } b > 0 { chars read append b } encoding = get encoding chars read to encoding == { input stream reader pbstream u t f 8 } chars read set length 0 { input stream reader pbstream encoding } unsupported encoding e { input stream reader pbstream u t f 8 } chars read append b input stream reader pbstream u t f 8 } } /** * initializes the xml reader * * @param stream the input the xml data * * @throws io i o *		if an i/ o occurred */ std xml reader input stream stream i o { pushback input stream pbstream = pushback input stream stream buffer chars read = buffer reader reader = stream2reader stream chars read current reader = stacked reader readers = stack current reader line reader = line number reader reader current reader pb reader = pushback reader current reader line reader 2 current reader = { current reader = u r l } malformed u r l e { never happens } start stream reader chars read to } /** * reads a character * * @return the character * * @throws io i o *		if no character could be read */ read i o { ch = current reader pb reader read ch < 0 { readers empty { i o unexpected e o f } current reader pb reader close current reader = stacked reader readers pop ch = current reader pb reader read } ch } /** * the current stream has no more characters left to be * read * * @throws io i o *		if an i/ o occurred */ at e o f of current stream i o { ch = current reader pb reader read ch < 0 { } { current reader pb reader unread ch } } /** * there are no more characters left to be read * * @throws io i o *		if an i/ o occurred */ at e o f i o { ch = current reader pb reader read ch < 0 { readers empty { } current reader pb reader close current reader = stacked reader readers pop ch = current reader pb reader read } current reader pb reader unread ch } /** * pushes the last character read back to the stream * * @param ch the character to push back * * @throws io i o * an i/ o occurred */ unread ch i o { current reader pb reader unread ch } /** * opens a stream from a and * * @param the which may be * @param the which is never * * @throws net malformed u r l * the does not contain a valid u r l * @throws io not found * the refers to a local which does not * @throws io i o * an occurred opening the stream */ reader open stream malformed u r l not found i o { u r l url = u r l current reader url get ref != { ref = url get ref url get length > 0 { url = u r l url get protocol url get host url get port url get url = u r l jar + url + '!' + ref } { url = std xml reader get resource ref } } current reader = current reader = url buffer chars read = buffer reader reader = stream2reader url open stream chars read chars read length == 0 { reader } chars read str = chars read to pushback reader pbreader = pushback reader reader chars read str length i = chars read str length 1 i >= 0 i { pbreader unread chars read str at i } pbreader } /** * starts a stream from a reader the stream is used * temporary to read data from that stream is exhausted control * to the parent stream * * @param reader the non reader to read the data from */ start stream reader reader { start stream reader } /** * starts a stream from a reader the stream is used * temporary to read data from that stream is exhausted control * to the parent stream * * @param reader the non reader to read the data from * @param is internal entity the reader is produced by resolving * an internal entity */ start stream reader reader is internal entity { stacked reader old reader = current reader readers push current reader current reader = stacked reader is internal entity { current reader line reader = current reader pb reader = pushback reader reader 2 } { current reader line reader = line number reader reader current reader pb reader = pushback reader current reader line reader 2 } current reader = old reader current reader = old reader } /** * the current level of the stream on the stack of streams */ get stream level { readers size } /** * the line number of the data in the current stream */ get line nr { current reader line reader == { stacked reader sr = stacked reader readers peek sr line reader == { 0 } { sr line reader get line number + 1 } } current reader line reader get line number + 1 } /** * sets the of the current stream * * @param the * * @throws net malformed u r l * the does not contain a valid u r l */ set malformed u r l { current reader = u r l current reader } /** * sets the of the current stream * * @param the */ set { current reader = } /** * the current */ get { current reader to } /** * the current */ get { current reader }} 
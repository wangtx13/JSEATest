/* * @ # composite figure 2 2 2006 07 08 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * */package draw io i o * * * geom * * event * undo * geom * xml dom input xml dom output /** * a figure that is composed of several children a composite figure * doesn't define any layout behavior it is up to subclassers to * arrange the contained children * * * @author werner randelshofer * @version 2 2 2006 07 08 minor changes * <br>2 1 2006 03 15 fire undoable edit on attribute change * <br>2 0 1 2006 02 06 fixed concurrent modification in * remove notify * <br>2 0 2006 01 14 changed to support precision coordinates * <br>1 0 2003 12 01 derived from 5 4b1 */public composite figure figure composite figure { /** * the children that figure is composed of * * @see #add * @see #remove child */ linked list< figure> children = linked list< figure> /** * cached draw bounds */ rectangle2 d draw bounds /** * cached layout bounds */ rectangle2 d bounds /** * a layouter determines how the composite figure should * be laid out graphically */ layouter layouter /** * handles figure changes in the children */ child handler child handler = child handler child handler figure listener undoable edit listener { composite figure owner child handler composite figure owner { owner = owner } figure request remove figure event e { owner remove e get figure } figure removed figure event evt { owner remove evt get figure } figure changed figure event e { ! owner is changing { owner will change owner fire figure changed e owner changed } } figure added figure event e { } figure attribute changed figure event e { } figure area invalidated figure event e { ! owner is changing { owner fire area invalidated e get invalidated area } } undoable edit happened undoable edit event e { owner fire undoable edit happened e get edit } } /** creates a instance */ composite figure { } collection< handle> create handles detail level { detail level == 0 { create handles 0 } /*else { linked list< handle> handles = linked list< handle> figure child children { handles add all child create handles detail level 1 } handles }*/ linked list< handle> handles = linked list< handle> handles } add figure figure { add get child count figure } add index figure figure { will change basic add index figure get drawing != { figure add notify get drawing } changed } add all collection< figure> figures { will change figure f figures { basic add get child count f get drawing != { f add notify get drawing } } changed } basic add figure figure { basic add get child count figure } basic add index figure figure { children add index figure figure add figure listener child handler figure add undoable edit listener child handler } basic add all collection< figure> figures { figure f figures { basic add get child count f } } add notify drawing drawing { add notify drawing figure child children { child add notify drawing } } remove notify drawing drawing { copy children collection to avoid concurrent modification figure child linked list< figure> children { child remove notify drawing } remove notify drawing } remove figure figure { index = children index of figure index == 1 { } { will change basic remove child index get drawing != { figure remove notify get drawing } changed } } figure remove child index { will change figure removed = basic remove child index get drawing != { removed remove notify get drawing } changed removed } basic remove figure figure { index = children index of figure index == 1 { } { basic remove child index } } figure basic remove child index { figure figure = children remove index figure remove figure listener child handler figure remove undoable edit listener child handler figure } /** * removes all children * * @see #add */ remove all children { will change children size > 0 { figure f = basic remove child children size 1 get drawing != { f add notify get drawing } } changed } basic remove all children { children size > 0 { figure f = basic remove child children size 1 } } /** * sends a figure to the back of the composite figure * * @param figure that is part of composite figure */ send to back figure figure { children remove figure { children add 0 figure figure invalidate } } /** * sends a figure to the front of the drawing * * @param figure that is part of the drawing */ send to front figure figure { children remove figure { children add figure figure invalidate } } /** * transforms the figure */ basic transform affine transform tx { figure f children { f basic transform tx } invalidate bounds } basic set bounds point2 d anchor point2 d { rectangle2 d old bounds = get bounds rectangle2 d bounds = rectangle2 d math min anchor x x math min anchor y y math abs anchor x x math abs anchor y y sx = bounds width / old bounds width sy = bounds height / old bounds height affine transform tx = affine transform tx translate old bounds x old bounds y ! is na n sx ! is na n sy sx != 1d || sy != 1d ! sx < 0 0001 ! sy < 0 0001 { basic transform tx tx set to identity tx scale sx sy basic transform tx tx set to identity } tx translate bounds x bounds y basic transform tx } undoable edit happened undoable edit event e { fire undoable edit happened e get edit } list< figure> get children { collections unmodifiable list children } get child count { children size } figure get child index { children get index } /** * an iterator to iterate in * z order front to back over the children */ list< figure> get children front to back { children == ? linked list< figure> reversed list< figure> children } set attribute attribute key name value { will change figure child children { child set attribute name value } changed } basic set attribute attribute key name value { figure child children { child basic set attribute name value } } get attribute attribute key name { } contains point2 d p { get draw bounds contains p { figure child get children front to back { child is visible child contains p } } } figure find figure inside point2 d p { get draw bounds contains p { figure found = figure child get children front to back { child is visible { found = child find figure inside p found != { found } } } } } figure find child point2 d p { get bounds contains p { figure found = figure child get children front to back { child is visible child contains p { child } } } } find child index point2 d p { figure child = find child p child == ? 1 children index of child } /** * get a layouter which encapsulated a layout * algorithm figure typically a layouter * accesses the child components of figure and arranges * their graphical presentation * * * @return layout strategy used by figure */ layouter get layouter { layouter } /** * a layout algorithm is used to define how the child components * should be laid out in relation to each other the task * layouting the child components presentation is delegated * to a layouter which can be plugged in at runtime */ layout { get layouter != { rectangle2 d bounds = get bounds point2 d p = point2 d bounds x bounds y rectangle2 d r = get layouter layout p p basic set bounds point2 d r x r y point2 d r x + r width r y + r height invalidate bounds } } /** * set a layouter which encapsulated a layout * algorithm figure typically a layouter * accesses the child components of figure and arranges * their graphical presentation it is a good idea to set * the layouter in the initialize * so it can be recreated a graphical composite figure is * read and restored from a storable input stream * * * @param layouter	encapsulation of a layout algorithm */ set layouter layouter layouter { layouter = layouter } dimension2 d get preferred size { layouter != { rectangle2 d r = layouter calculate layout get start point get end point dimension2 d r width r height } { get preferred size } } rectangle2 d get figure draw bounds { draw bounds == { figure child get children front to back { child is visible { rectangle2 d child bounds = child get draw bounds ! child bounds is empty { draw bounds == { draw bounds = child bounds } { draw bounds add child bounds } } } } } draw bounds == ? rectangle2 d 0 0 1 1 rectangle2 d draw bounds clone } rectangle2 d get bounds { bounds == { figure child get children front to back { child is visible { bounds == { bounds = child get bounds } { bounds add child get bounds } } } } bounds == ? rectangle2 d 0 0 1 1 rectangle2 d bounds clone } draw figure graphics2 d g { figure child children { child is visible { child draw g } } is connectors visible { draw connectors g } } draw connectors graphics2 d g { } composite figure clone { composite figure that = composite figure clone that child handler = child handler that that children = linked list< figure> figure child children { figure that child = figure child clone that children add that child that child add figure listener that child handler that child add undoable edit listener that child handler } that } invalidate bounds { bounds = draw bounds = } collection< figure> get decomposition { linked list< figure> list = linked list< figure> list add list add all get children list } read dom input in i o { in open element children i=0 i < in get element count i++ { add figure in read i } in close element } write dom output out i o { out open element children figure child get children { out write child } out close element } map< attribute key object> get attributes { hash map< attribute key object> } restore to geometry { linked list list = linked list geometry index = 0 geom list { get child index restore to geom index++ } invalidate bounds } get restore data { linked list< object> list = linked list< object> figure child children { list add child get restore data } list } will change { will change get changing depth == 1 { figure child children { child will change } } } changed { get changing depth == 1 { figure child children { child changed } } changed } invalidate { invalidate invalidate bounds } validate { validate layout invalidate bounds } remove attribute attribute key key { nothing } has attribute attribute key key { }} 
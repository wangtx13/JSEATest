/* content reader nano xml/ * * $ revision 1 4 $ * $ date 2002/01/04 21 03 28 $ * $ name r e l e a s e 2 2 1 $ * * is part of nano xml 2 * copyright c 2000 2002 marc de scheemaecker all rights reserved * * software is provided 'as is' without any express or implied warranty * in no event will the authors be held liable any damages arising from the * use of software * * permission is granted to anyone to use software any purpose * including commercial applications and to alter it and redistribute it * freely subject to the following restrictions * * 1 the origin of software must not be misrepresented you must not * claim that you wrote the original software you use software in * a product an acknowledgment in the product documentation would be * appreciated but is not required * * 2 altered source versions must be plainly marked as such and must not be * misrepresented as being the original software * * 3 notice may not be removed or altered from any source distribution */package net n3 nanoxml io reader io i o /** * reader reads data from another reader until a element has * been encountered * * @author marc de scheemaecker * @version $ name r e l e a s e 2 2 1 $ $ revision 1 4 $ */class content reader reader{ /** * the encapsulated reader */ i xml reader reader /** * buffer */ buffer /** * pointer into the buffer */ buffer index /** * the entity resolver */ i xml entity resolver resolver /** * creates the reader * * @param reader the encapsulated reader * @param resolver the entity resolver * @param buffer data that has already been read from <code>reader</code> */ content reader i xml reader reader i xml entity resolver resolver buffer { reader = reader resolver = resolver buffer = buffer buffer index = 0 } /** * cleans up the when it's destroyed */ finalize throwable { reader = resolver = buffer = finalize } /** * reads a block of data * * @param output buffer where to put the read data * @param offset first position in buffer to put the data * @param size maximum number of chars to read * * @return the number of chars read or 1 at e o f * * @throws io i o *		if an occurred reading the data */ read output buffer offset size i o { { chars read = 0 buffer length = buffer length offset + size > output buffer length { size = output buffer length offset } chars read < size { str = ch buffer index >= buffer length { str = xml read reader ' ' ch = str at 0 } { ch = buffer at buffer index buffer index++ output buffer chars read = ch chars read++ don't interprete chars in the buffer } ch == '<' { reader unread ch } ch == ' ' str length > 1 { str at 1 == '#' { ch = xml process literal str } { xml process entity str reader resolver } } output buffer chars read = ch chars read++ } chars read == 0 { chars read = 1 } chars read } xml parse e { i o e get message } } /** * skips remaining data and closes the stream * * @throws io i o *		if an occurred reading the data */ close i o { { buffer length = buffer length { str = ch buffer index >= buffer length { str = xml read reader ' ' ch = str at 0 } { ch = buffer at buffer index buffer index++ don't interprete chars in the buffer } ch == '<' { reader unread ch } ch == ' ' str length > 1 { str at 1 != '#' { xml process entity str reader resolver } } } } xml parse e { i o e get message } }} 
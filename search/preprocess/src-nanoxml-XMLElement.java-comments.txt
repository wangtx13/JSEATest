/* werner randelshofer 2006 05 26 * replaced 1 1 collections by 1 2 collections * removed all deprecated * added create element name * added get attribute name min max value * added get attribute name value * added print writer w * write encoded can be changed to not encode unicode characters 2006 05 02 * * xml element * * $ revision 1 4 $ * $ date 2002/03/24 10 27 59 $ * $ name r e l e a s e 2 2 1 $ * * is part of nano xml 2 lite * copyright c 2000 2002 marc de scheemaecker all rights reserved * * software is provided 'as is' without any express or implied warranty * in no event will the authors be held liable any damages arising from the * use of software * * permission is granted to anyone to use software any purpose * including commercial applications and to alter it and redistribute it * freely subject to the following restrictions * * 1 the origin of software must not be misrepresented you must not * claim that you wrote the original software you use software in * a product an acknowledgment in the product documentation would be * appreciated but is not required * * 2 altered source versions must be plainly marked as such and must not be * misrepresented as being the original software * * 3 notice may not be removed or altered from any source distribution *****************************************************************************/package nanoxml io * * /** * xml element is a representation of an xml the is able to parse * xml * < p>< d l> * < d t>< b> parsing xml data</ b></ d t> * < d d> * you can parse xml data using the following * < u l>< c o d e> * xml element xml = xml element < b r> * reader reader = reader filename xml < b r> * xml parse from reader reader * </ c o d e></ u l></ d d></ d l> * < d l>< d t>< b> retrieving attributes</ b></ d t> * < d d> * you can enumerate the attributes of an element using the * {@link #enumerate attribute names enumerate attribute names} * the attribute values can be retrieved using the * {@link #get attribute get attribute} * the following example shows how to list the attributes of an element * < u l>< c o d e> * xml element element = < b r> * iterator iter = element get attribute names < b r> * iter has next {< b r> * key = iter next < b r> * value = element get attribute key < b r> * out key + = + value < b r> * } * </ c o d e></ u l></ d d></ d l> * < d l>< d t>< b> retrieving child elements</ b></ d t> * < d d> * you can enumerate the children of an element using * {@link #iterate children iterate children} * the number of child iterator can be retrieved using * {@link #count children count children} * </ d d></ d l> * < d l>< d t>< b> elements containing character data</ b></ d t> * < d d> * an iterator contains character data like in the following example * < u l>< c o d e> * lt title the title lt /title * </ c o d e></ u l> * you can retrieve that data using the * {@link #get content get content} * </ d d></ d l> * < d l>< d t>< b> subclassing xml element</ b></ d t> * < d d> * when subclassing xml element you need to override the * {@link #create element create element} * which has to a copy of the receiver * </ d d></ d l> * < p> * * @author marc de scheemaecker * lt < a href= mailto cyberelf@mac com >cyberelf@mac com</ a> * @version 2005 06 18 werner randelshofer adapted 2 collections a p i * <br>$ name r e l e a s e 2 2 1 $ $ revision 1 4 $ * @see nanoxml xml parse */public xml element{ /** * serialization serial */ serial u = 6685035139346394777 l /** * major of nano xml classes with the same major and minor * are binary compatible classes with the same major * are source compatible the major is different you may * need to modify the client source * * @see # n a n o xml m i n o r v e r s i o n */ n a n o xml m a j o r v e r s i o n = 2 /** * minor of nano xml classes with the same major and minor * are binary compatible classes with the same major * are source compatible the major is different you may * need to modify the client source * * @see # n a n o xml m a j o r v e r s i o n */ n a n o xml m i n o r v e r s i o n = 2 /** * the attributes given to the element * * <dl><dt><b> invariants </b></dt><dd> * <ul><li> the field can be empty * <li> the field is never <code>null</code> * <li> the key set iterator and the values are strings * </ul></dd></dl> */ hash map attributes /** * child iterator of the element * * <dl><dt><b> invariants </b></dt><dd> * <ul><li> the field can be empty * <li> the field is never <code>null</code> * <li> the iterator are instances of <code> xml element</code> * or a subclass of <code> xml element</code> * </ul></dd></dl> */ list children /** * the name of the element * * <dl><dt><b> invariants </b></dt><dd> * <ul><li> the field is <code>null</code> iff the element is not * initialized by either parse or set name * <li> the field is not <code>null</code> it's not empty * <li> the field is not <code>null</code> it contains a valid * xml identifier * </ul></dd></dl> */ name /** * the # p c d a t a content of the * * <dl><dt><b> invariants </b></dt><dd> * <ul><li> the field is <code>null</code> iff the element is not a * # p c d a t a element * <li> the field can be any including the empty * </ul></dd></dl> */ contents /** * conversion table amp entities the key set iterator are the entity names * without the amp and delimiters * * <dl><dt><b> invariants </b></dt><dd> * <ul><li> the field is never <code>null</code> * <li> the field always contains the following associations * lt = lt = * = \ apos = ' * amp = amp * <li> the key set iterator are strings * <li> the values are arrays * </ul></dd></dl> */ hash map entities /** * the line number where the element starts * * <dl><dt><b> invariants </b></dt><dd> * <ul><li><code>line nr gt= 0</code> * </ul></dd></dl> */ line nr /** * <code>true</code> the of the element and attribute names * are insensitive */ ignore /** * <code>true</code> the leading and trailing whitespace of # p c d a t a * sections have to be ignored */ ignore whitespace /** * character read too much * character provides push back functionality to the input reader * without having to use a pushback reader * there is no such character field is '\0' */ read too much /** * the reader provided by the caller of the parse * * <dl><dt><b> invariants </b></dt><dd> * <ul><li> the field is not <code>null</code> the parse * is running * </ul></dd></dl> */ reader reader /** * the current line number in the source content * * <dl><dt><b> invariants </b></dt><dd> * <ul><li>parser line nr 0 the parse is running * </ul></dd></dl> */ parser line nr /** * werner randelshofer variable is set to unicode * characters are not encoded into entities the encoding is left * to the underlying writer */ is encode unicode characters = /** * creates and initializes a xml element * calling the construction is equivalent to * <ul><code>new xml element hash map * </code></ul> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>count children = 0 * <li>iterate children = empty enumeration * <li>enumerate property names = empty enumeration * <li>get children = empty vector * <li>get content = * <li>get line nr = 0 * <li>get name = * </ul></dd></dl> * * @see # xml element hash map * xml element hash map * @see # xml element * @see # xml element hash map * xml element hash map */ xml element { hash map } /** * creates and initializes a xml element * calling the construction is equivalent to * <ul><code>new xml element entities * </code></ul> * * @param entities * the entity conversion table * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>entities != null</code> * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>count children = 0 * <li>iterate children = empty enumeration * <li>enumerate property names = empty enumeration * <li>get children = empty vector * <li>get content = * <li>get line nr = 0 * <li>get name = * </ul></dd></dl><dl> * * @see # xml element * @see # xml element * @see # xml element hash map * xml element hash map */ xml element hash map entities { entities } /** * creates and initializes a xml element * calling the construction is equivalent to * <ul><code>new xml element hash map skip leading whitespace * </code></ul> * * @param skip leading whitespace * <code>true</code> leading and trailing whitespace in p c d a t a * content has to be removed * * </dl><dl><dt><b> postconditions </b></dt><dd> * <ul><li>count children = 0 * <li>iterate children = empty enumeration * <li>enumerate property names = empty enumeration * <li>get children = empty vector * <li>get content = * <li>get line nr = 0 * <li>get name = * </ul></dd></dl><dl> * * @see # xml element * @see # xml element hash map * xml element hash map * @see # xml element hash map * xml element hash map */ xml element skip leading whitespace { hash map skip leading whitespace } /** * creates and initializes a xml element * calling the construction is equivalent to * <ul><code>new xml element entities skip leading whitespace * </code></ul> * * @param entities * the entity conversion table * @param skip leading whitespace * <code>true</code> leading and trailing whitespace in p c d a t a * content has to be removed * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>entities != null</code> * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>count children = 0 * <li>iterate children = empty enumeration * <li>enumerate property names = empty enumeration * <li>get children = empty vector * <li>get content = * <li>get line nr = 0 * <li>get name = * </ul></dd></dl><dl> * * @see # xml element * @see # xml element * @see # xml element hash map * xml element hash map */ xml element hash map entities skip leading whitespace { entities skip leading whitespace } /** * creates and initializes a xml element * * @param entities * the entity conversion table * @param skip leading whitespace * <code>true</code> leading and trailing whitespace in p c d a t a * content has to be removed * @param ignore * <code>true</code> the of element and attribute names have * to be ignored * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>entities != null</code> * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>count children = 0 * <li>iterate children = empty enumeration * <li>enumerate property names = empty enumeration * <li>get children = empty vector * <li>get content = * <li>get line nr = 0 * <li>get name = * </ul></dd></dl><dl> * * @see # xml element * @see # xml element * @see # xml element hash map * xml element hash map * @see # xml element hash map * xml element hash map */ xml element hash map entities skip leading whitespace ignore { entities skip leading whitespace ignore } /** * creates and initializes a xml element * < p> * constructor should < i>only</ i> be called from * {@link #create element create element} * to create child iterator * * @param entities * the entity conversion table * @param skip leading whitespace * <code>true</code> leading and trailing whitespace in p c d a t a * content has to be removed * @param fill basic conversion table * <code>true</code> the basic entities need to be added to * the entity list * @param ignore * <code>true</code> the of element and attribute names have * to be ignored * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>entities != null</code> * <li>if <code>fill basic conversion table == false</code> * then <code>entities</code> contains at least the following * entries <code>amp</code> <code>lt</code> <code>gt</code> * <code>apos</code> and <code>quot</code> * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>count children = 0 * <li>iterate children = empty enumeration * <li>enumerate property names = empty enumeration * <li>get children = empty vector * <li>get content = * <li>get line nr = 0 * <li>get name = * </ul></dd></dl><dl> * @see #create element */ xml element hash map entities skip leading whitespace fill basic conversion table ignore { entities skip leading whitespace fill basic conversion table ignore } xml element hash map entities skip leading whitespace fill basic conversion table ignore encode unicode characters { ignore whitespace = skip leading whitespace ignore = ignore name = contents = attributes = hash map children = list entities = entities line nr = 0 is encode unicode characters = encode unicode characters iterator iter = entities key set iterator iter has next { key = iter next value = entities get key value { value = value to entities put key value } } fill basic conversion table { entities put amp { ' ' } entities put { ' ' } entities put apos { '\'' } entities put lt { '<' } entities put { '>' } } } /** * adds a child element * * @param child * the child element to add * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>child != null</code> * <li><code>child get name != null</code> * <li><code>child</code> does not have a parent element * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>count children = old count children + 1 * <li>iterate children = old iterate children + child * <li>get children = old iterate children + child * </ul></dd></dl><dl> * * @see #count children * @see #iterate children * @see #get children * @see #remove child nanoxml xml element * remove child xml element */ add child xml element child { children add child } /** * adds or modifies an attribute * * @param name * the name of the attribute * @param value * the value of the attribute * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * <li><code>value != null</code> * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>enumerate attribute names * = old enumerate attribute names + name * <li>get attribute name = value * </ul></dd></dl><dl> * */ set attribute name value { ignore { name = name to upper } attributes put name value to } /** * adds or modifies an attribute * * @param name * the name of the attribute * @param value * the value of the attribute * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>enumerate attribute names * = old enumerate attribute names + name * <li>get attribute name = value * </ul></dd></dl><dl> * */ set attribute name value { ignore { name = name to upper } attributes put name to value } /** * adds or modifies an attribute * * @param name * the name of the attribute * @param value * the value of the attribute * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>enumerate attribute names * = old enumerate attribute names + name * <li>get attribute name = value * </ul></dd></dl><dl> * */ set attribute name value { ignore { name = name to upper } attributes put name to value } /** * the number of child iterator of the element * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li><code>result >= 0</code> * </ul></dd></dl> * * @see #add child nanoxml xml element * add child xml element * @see #iterate children * @see #get children * @see #remove child nanoxml xml element * remove child xml element */ count children { children size } /** * enumerates the attribute names * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li><code>result != null</code> * </ul></dd></dl> * */ iterator enumerate attribute names { attributes key set iterator } /** * enumerates the child iterator * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li><code>result != null</code> * </ul></dd></dl> * */ iterator iterate children { children iterator } /** * the child iterator as a list it is safe to modify * list * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li><code>result != null</code> * </ul></dd></dl> * * @see #add child nanoxml xml element * add child xml element * @see #count children * @see #iterate children * @see #remove child nanoxml xml element * remove child xml element */ list get children { { list children clone } e { never happens however some compilers are so braindead that they require clause } } /** * the p c d a t a content of the there is no such content * < c o d e>null</ c o d e> is * * @see #set content * set content */ get content { contents } /** * the line nr in the source data on which the element is found * <code>0</code> there is no associated source data * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li><code>result >= 0</code> * </ul></dd></dl> */ get line nr { line nr } /** * an attribute of the element * the attribute doesn't <code>null</code> is * * @param name the name of the attribute * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * </ul></dd></dl><dl> * */ get attribute name { get attribute name } /** * an attribute of the element * the attribute doesn't <code>default value</code> is * * @param name the name of the attribute * @param value key to use the attribute is missing * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * </ul></dd></dl><dl> * */ get attribute name value { ignore { name = name to upper } value = attributes get name value == { value = value } value } /** * an attribute by looking up a key in a hashtable * the attribute doesn't the value corresponding to key * is * < p> * as an example value set contains the mapping <code> one = * 1 </code> * and the element contains the attribute <code>attr= one </code> then * <code>get attribute attr mapping key </code> * <code> 1 </code> * * @param name * the name of the attribute * @param value set * hash map mapping key set iterator to values * @param key * key to use the attribute is missing * @param allow literals * <code>true</code> literals are valid * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * <li><code>value set</code> != * <li>the key set iterator of <code>value set</code> are strings * </ul></dd></dl><dl> * * @see #set attribute * set attribute * @see #remove attribute * remove attribute * @see #enumerate attribute names * @see #get attribute * get attribute * @see #get attribute * get attribute */ get attribute name map value set key allow literals { ignore { name = name to upper } key = attributes get name result key == { key = key } result = value set get key result == { allow literals { result = key } { invalid value name key } } result } /** * an attribute of the element * the attribute doesn't <code>null</code> is * * @param name the name of the attribute * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * </ul></dd></dl><dl> * * @see #set attribute * set attribute * @see #remove attribute * remove attribute * @see #enumerate attribute names * @see #get attribute * * get attribute * @see #get attribute * hash map * * get attribute hash map */ get attribute name { get attribute name } /** * an attribute of the element * the attribute doesn't <code>default value</code> is * * @param name the name of the attribute * @param value key to use the attribute is missing * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * </ul></dd></dl><dl> * * @see #set attribute * set attribute * @see #remove attribute * remove attribute * @see #enumerate attribute names * @see #get attribute * get attribute * @see #get attribute * hash map * * get attribute hash map */ get attribute name value { get attribute name value } /** * an attribute by looking up a key in a hashtable * the attribute doesn't the value corresponding to key * is * < p> * as an example value set contains the mapping <code> one = * 1 </code> * and the element contains the attribute <code>attr= one </code> then * <code>get attribute attr mapping key </code> * <code> 1 </code> * * @param name * the name of the attribute * @param value set * hash map mapping key set iterator to values * @param key * key to use the attribute is missing * @param allow literals * <code>true</code> literals are valid * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * <li><code>value set</code> != * <li>the key set iterator of <code>value set</code> are strings * <li>the values of <code>value set</code> are strings * </ul></dd></dl><dl> * * @see #set attribute * set attribute * @see #remove attribute * remove attribute * @see #enumerate attribute names * @see #get attribute * get attribute * @see #get attribute * * get attribute */ get attribute name hash map value set key allow literals { get attribute name value set key allow literals } /** * an attribute of the element * the attribute doesn't <code>0</code> is * * @param name the name of the attribute * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * </ul></dd></dl><dl> * * @see #set attribute * set attribute * @see #enumerate attribute names * @see #get attribute * get attribute * @see #get attribute * hash map * * get attribute hash map */ get attribute name { get attribute name 0 } /** * an attribute of the element * the attribute doesn't <code>default value</code> is * * @param name the name of the attribute * @param value key to use the attribute is missing * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * </ul></dd></dl><dl> * * @see #set attribute * set attribute * @see #enumerate attribute names * @see #get attribute * get attribute * @see #get attribute * hash map * * get attribute hash map */ get attribute name value { ignore { name = name to upper } value = attributes get name value == { value } { { parse value } number format e { invalid value name value } } } get attribute name min max value { v = get attribute name value v < min min v > max max v } /** * an attribute by looking up a key in a hashtable * the attribute doesn't the value corresponding to key * is * < p> * as an example value set contains the mapping <code> one = 1</code> * and the element contains the attribute <code>attr= one </code> then * <code>get attribute attr mapping key </code> * <code>1</code> * * @param name * the name of the attribute * @param value set * hash map mapping key set iterator to values * @param key * key to use the attribute is missing * @param allow literal numbers * <code>true</code> literal numbers are valid * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * <li><code>value set</code> != * <li>the key set iterator of <code>value set</code> are strings * <li>the values of <code>value set</code> are * <li><code>default key</code> is either <code>null</code> a * key in <code>value set</code> or an * </ul></dd></dl><dl> * * @see #set attribute * set attribute * @see #enumerate attribute names * @see #get attribute * get attribute * @see #get attribute * get attribute */ get attribute name hash map value set key allow literal numbers { ignore { name = name to upper } key = attributes get name result key == { key = key } { result = value set get key } cast e { invalid value set name } result == { ! allow literal numbers { invalid value name key } { result = value of key } number format e { invalid value name key } } result value } /** * an attribute of the element * the attribute doesn't <code>0 0</code> is * * @param name the name of the attribute * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * </ul></dd></dl><dl> * * @see #set attribute * set attribute * @see #enumerate attribute names * @see #get attribute * get attribute * @see #get attribute * hash map * * get attribute hash map */ get attribute name { get attribute name 0 } /** * an attribute of the element * the attribute doesn't <code>default value</code> is * * @param name the name of the attribute * @param value key to use the attribute is missing * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * </ul></dd></dl><dl> * * @see #set attribute * set attribute * @see #enumerate attribute names * @see #get attribute * get attribute * @see #get attribute * hash map * * get attribute hash map */ get attribute name value { ignore { name = name to upper } value = attributes get name value == { value } { { value of value value } number format e { invalid value name value } } } /** * an attribute by looking up a key in a hashtable * the attribute doesn't the value corresponding to key * is * < p> * as an example value set contains the mapping <code> one = * 1 0</code> * and the element contains the attribute <code>attr= one </code> then * <code>get attribute attr mapping key </code> * <code>1 0</code> * * @param name * the name of the attribute * @param value set * hash map mapping key set iterator to values * @param key * key to use the attribute is missing * @param allow literal numbers * <code>true</code> literal numbers are valid * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * <li><code>value set != null</code> * <li>the key set iterator of <code>value set</code> are strings * <li>the values of <code>value set</code> are * <li><code>default key</code> is either <code>null</code> a * key in <code>value set</code> or a * </ul></dd></dl><dl> * * @see #set attribute * set attribute * @see #enumerate attribute names * @see #get attribute * get attribute * @see #get attribute * get attribute */ get attribute name hash map value set key allow literal numbers { ignore { name = name to upper } key = attributes get name result key == { key = key } { result = value set get key } cast e { invalid value set name } result == { ! allow literal numbers { invalid value name key } { result = value of key } number format e { invalid value name key } } result value } /** * an attribute of the element * the attribute doesn't <code>default value</code> is * the value of the attribute is equal to <code>true value</code> * <code>true</code> is * the value of the attribute is equal to <code>false value</code> * <code>false</code> is * the value doesn't match <code>true value</code> or * <code>false value</code> an is thrown * * @param name the name of the attribute * @param value the value associated with <code>true</code> * @param value the value associated with <code>true</code> * @param value value to use the attribute is missing * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * <li><code>true value</code> and <code>false value</code> * are different strings * </ul></dd></dl><dl> * * @see #set attribute * set attribute * @see #remove attribute * remove attribute * @see #enumerate attribute names */ get attribute name value value value { ignore { name = name to upper } value = attributes get name value == { value } value equals value { } value equals value { } { invalid value name value } } get attribute name value { get attribute name value } /** * the name of the element * * @see #set name set name */ get name { name } /** * reads one xml element from a io reader and parses it * * @param reader * the reader from which to retrieve the xml data * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>reader != null</code> * <li><code>reader</code> is not closed * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>the state of the receiver is updated to reflect the xml element * parsed from the reader * <li>the reader points to the first character following the last * ' ' character of the xml element * </ul></dd></dl><dl> * * @throws io i o * an occured reading the input * @throws nanoxml xml parse * an occured parsing the read data */ parse from reader reader reader i o xml parse { parse from reader reader /*starting line nr*/ 1 } /** * reads one xml element from a io reader and parses it * * @param reader * the reader from which to retrieve the xml data * @param starting line nr * the line number of the first line in the data * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>reader != null</code> * <li><code>reader</code> is not closed * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>the state of the receiver is updated to reflect the xml element * parsed from the reader * <li>the reader points to the first character following the last * ' ' character of the xml element * </ul></dd></dl><dl> * * @throws io i o * an occured reading the input * @throws nanoxml xml parse * an occured parsing the read data */ parse from reader reader reader starting line nr i o xml parse { name = contents = attributes = hash map children = list read too much = '\0' reader = reader parser line nr = starting line nr { ch = scan whitespace ch != '<' { expected input < } ch = read ch == '!' || ch == '?' { skip special tag 0 } { unread ch scan element } } } /** * reads one xml element from a and parses it * * @param * the reader from which to retrieve the xml data * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>string != null</code> * <li><code>string length 0</code> * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>the state of the receiver is updated to reflect the xml element * parsed from the reader * </ul></dd></dl><dl> * * @throws nanoxml xml parse * an occured parsing the */ parse xml parse { { parse from reader reader /*starting line nr*/ 1 } i o e { handling suxx } } /** * reads one xml element from a and parses it * * @param * the reader from which to retrieve the xml data * @param offset * the first character in <code>string</code> to scan * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>string != null</code> * <li><code>offset lt length </code> * <li><code>offset = 0</code> * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>the state of the receiver is updated to reflect the xml element * parsed from the reader * </ul></dd></dl><dl> * * @throws nanoxml xml parse * an occured parsing the */ parse offset xml parse { parse substring offset } /** * reads one xml element from a and parses it * * @param * the reader from which to retrieve the xml data * @param offset * the first character in <code>string</code> to scan * @param end * the character where to stop scanning * character is not scanned * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>string != null</code> * <li><code>end lt = length </code> * <li><code>offset lt end</code> * <li><code>offset = 0</code> * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>the state of the receiver is updated to reflect the xml element * parsed from the reader * </ul></dd></dl><dl> * * @throws nanoxml xml parse * an occured parsing the */ parse offset end xml parse { parse substring offset end } /** * reads one xml element from a and parses it * * @param * the reader from which to retrieve the xml data * @param offset * the first character in <code>string</code> to scan * @param end * the character where to stop scanning * character is not scanned * @param starting line nr * the line number of the first line in the data * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>string != null</code> * <li><code>end lt = length </code> * <li><code>offset lt end</code> * <li><code>offset = 0</code> * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>the state of the receiver is updated to reflect the xml element * parsed from the reader * </ul></dd></dl><dl> * * @throws nanoxml xml parse * an occured parsing the */ parse offset end starting line nr xml parse { = substring offset end { parse from reader reader starting line nr } i o e { handling suxx } } /** * reads one xml element from a and parses it * * @param input * the reader from which to retrieve the xml data * @param offset * the first character in <code>string</code> to scan * @param end * the character where to stop scanning * character is not scanned * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>input != null</code> * <li><code>end lt = input length</code> * <li><code>offset lt end</code> * <li><code>offset = 0</code> * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>the state of the receiver is updated to reflect the xml element * parsed from the reader * </ul></dd></dl><dl> * * @throws nanoxml xml parse * an occured parsing the */ parse input offset end xml parse { parse input offset end /*starting line nr*/ 1 } /** * reads one xml element from a and parses it * * @param input * the reader from which to retrieve the xml data * @param offset * the first character in <code>string</code> to scan * @param end * the character where to stop scanning * character is not scanned * @param starting line nr * the line number of the first line in the data * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>input != null</code> * <li><code>end lt = input length</code> * <li><code>offset lt end</code> * <li><code>offset = 0</code> * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>the state of the receiver is updated to reflect the xml element * parsed from the reader * </ul></dd></dl><dl> * * @throws nanoxml xml parse * an occured parsing the */ parse input offset end starting line nr xml parse { { reader reader = reader input offset end parse from reader reader starting line nr } i o e { will never happen } } /** * removes a child element * * @param child * the child element to remove * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>child != null</code> * <li><code>child</code> is a child element of the receiver * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>count children = old count children 1 * <li>iterate children = old iterate children child * <li>get children = old iterate children child * </ul></dd></dl><dl> * * @see #add child nanoxml xml element * add child xml element * @see #count children * @see #iterate children * @see #get children */ remove child xml element child { children remove child } /** * removes an attribute * * @param name * the name of the attribute * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li>enumerate attribute names * = old enumerate attribute names name * <li>get attribute name = <code>null</code> * </ul></dd></dl><dl> * */ remove attribute name { ignore { name = name to upper } attributes remove name } /** * creates a similar xml element */ xml element create element name { xml element elem = create element elem set name name elem } /** * creates a similar xml element * < p> * you should override when subclassing xml element */ xml element create element { xml element entities ignore whitespace ignore is encode unicode characters } /** * changes the content * * @param content * the content */ set content content { contents = content } /** * changes the name of the element * * @param name * the name * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name</code> is a valid xml identifier * </ul></dd></dl> * * @see #get name */ set name name { name = name } /** * writes the xml element to a * * @see #write io writer write writer */ to { { output stream out = output stream output stream writer writer = output stream writer out write writer writer flush out to } i o e { handling suxx to } } /** * writes the xml element to a writer * * @param writer * the writer to write the xml data to * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>writer != null</code> * <li><code>writer</code> is not closed * </ul></dd></dl> * * @throws io i o * the data could not be written to the writer * * @see #to */ write writer writer i o { name == { write encoded writer contents } writer write '<' writer write name ! attributes is empty { iterator iter = attributes key set iterator iter has next { writer write ' ' key = iter next value = attributes get key writer write key writer write '=' writer write ' ' write encoded writer value writer write ' ' } } contents != contents length > 0 { writer write '>' write encoded writer contents writer write '<' writer write '/' writer write name writer write '>' } children is empty { writer write '/' writer write '>' } { writer write '>' iterator iter = iterate children iter has next { xml element child = xml element iter next child write writer } writer write '<' writer write '/' writer write name writer write '>' } } /** * writes the xml element to a print writer and indents the elements * * @param writer * the writer to write the xml data to * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>writer != null</code> * <li><code>writer</code> is not closed * </ul></dd></dl> * * @throws io i o * the data could not be written to the writer * * @see #to */ print print writer writer { print writer 0 } /** * writes the xml element to a print writer and indents the elements * * @param writer * the writer to write the xml data to * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>writer != null</code> * <li><code>writer</code> is not closed * </ul></dd></dl> * * @param indent * the indentation * * @throws io i o * the data could not be written to the writer * * @see #to */ print print writer writer indent { { name == { write encoded writer contents } spaces = indent * 2 arrays fill spaces ' ' writer write spaces writer write '<' writer write name ! attributes is empty { iterator enm = attributes key set iterator enm has next { writer write ' ' key = enm next value = attributes get key writer write key writer write '=' writer write ' ' write encoded writer value writer write ' ' } } contents != contents length > 0 { writer write '>' write encoded writer contents writer write '<' writer write '/' writer write name writer write '>' } children is empty { writer write '/' writer write '>' } { writer write '>' writer write '\n' iterator enm = get children iterator enm has next { xml element child = xml element enm next child print writer indent + 1 } writer write spaces writer write '<' writer write '/' writer write name writer write '>' } writer write '\n' } i o e { internal = internal e get message init cause e } } /** * writes a encoded to a writer * * @param writer * the writer to write the xml data to * @param str * the to write encoded * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>writer != null</code> * <li><code>writer</code> is not closed * <li><code>str != null</code> * </ul></dd></dl> */ write encoded writer writer str i o { i = 0 i < str length i += 1 { ch = str at i ch { '<' writer write ' ' writer write 'l' writer write 't' writer write ' ' '>' writer write ' ' writer write 'g' writer write 't' writer write ' ' ' ' writer write ' ' writer write 'a' writer write 'm' writer write 'p' writer write ' ' ' ' writer write ' ' writer write 'q' writer write 'u' writer write 'o' writer write 't' writer write ' ' '\'' writer write ' ' writer write 'a' writer write 'p' writer write 'o' writer write 's' writer write ' ' unicode = ch unicode < 32 || is encode unicode characters unicode > 126 { writer write ' ' writer write '#' writer write 'x' writer write to unicode 16 writer write ' ' } { writer write ch } } } } /** * scans an identifier from the current reader * the scanned identifier is appended to <code>result</code> * * @param result * the buffer in which the scanned identifier will be put * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>result != null</code> * <li> the next character read from the reader is a valid first * character of an xml identifier * </ul></dd></dl> * * <dl><dt><b> postconditions </b></dt><dd> * <ul><li> the next character read from the reader won't be an identifier * character * </ul></dd></dl><dl> */ scan identifier buffer result i o { { ch = read ch < ' a' || ch > ' z' ch < 'a' || ch > 'z' ch < '0' || ch > '9' ch != ' ' ch != ' ' ch != ' ' ch != ' ' ch <= '\u007 e' { unread ch } result append ch } } /** * scans an identifier from the current reader * * @return the next character following the whitespace */ scan whitespace i o { { ch = read ch { ' ' '\t' '\n' '\r' ch } } } /** * scans an identifier from the current reader * the scanned whitespace is appended to <code>result</code> * * @return the next character following the whitespace * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>result != null</code> * </ul></dd></dl> */ scan whitespace buffer result i o { { ch = read ch { ' ' '\t' '\n' result append ch '\r' ch } } } /** * scans a delimited from the current reader * the scanned without delimiters is appended to * <code>string</code> * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>string != null</code> * <li>the next read is the delimiter * </ul></dd></dl> */ scan buffer i o { delimiter = read delimiter != '\'' delimiter != ' ' { expected input ' or \ } { ch = read ch == delimiter { } ch == ' ' { resolve entity } { append ch } } } /** * scans a # p c d a t a element c d a t a sections and entities are resolved * the next lt is skipped * the scanned data is appended to <code>data</code> * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>data != null</code> * </ul></dd></dl> */ scan p c data buffer data i o { { ch = read ch == '<' { ch = read ch == '!' { check c d a t a data } { unread ch } } ch == ' ' { resolve entity data } { data append ch } } } /** * scans a special tag and the tag is a c d a t a section append its * content to <code>buf</code> * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>buf != null</code> * <li> the first lt has already been read * </ul></dd></dl> */ check c d a t a buffer buf i o { ch = read ch != ' ' { unread ch skip special tag 0 } ! check literal c d a t a { skip special tag 1 one has already been read } { delimiter chars skipped = 0 delimiter chars skipped < 3 { ch = read ch { ' ' delimiter chars skipped < 2 { delimiter chars skipped += 1 } { buf append ' ' buf append ' ' delimiter chars skipped = 0 } '>' delimiter chars skipped < 2 { i = 0 i < delimiter chars skipped i++ { buf append ' ' } delimiter chars skipped = 0 buf append '>' } { delimiter chars skipped = 3 } i = 0 i < delimiter chars skipped i += 1 { buf append ' ' } buf append ch delimiter chars skipped = 0 } } } } /** * skips a comment * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li> the first lt ! has already been read * </ul></dd></dl> */ skip comment i o { dashes to read = 2 dashes to read > 0 { ch = read ch == ' ' { dashes to read = 1 } { dashes to read = 2 } } read != '>' { expected input > } } /** * skips a special tag or comment * * @param bracket level the number of open square brackets that have * already been read * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li> the first lt ! has already been read * <li><code>bracket level >= 0</code> * </ul></dd></dl> */ skip special tag bracket level i o { tag level = 1 < delimiter = '\0' bracket level == 0 { ch = read ch == ' ' { bracket level += 1 } ch == ' ' { ch = read ch == ' ' { bracket level += 1 } ch == ' ' { bracket level = 1 } ch == ' ' { skip comment } } } tag level > 0 { ch = read delimiter == '\0' { ch == ' ' || ch == '\'' { delimiter = ch } bracket level <= 0 { ch == '<' { tag level += 1 } ch == '>' { tag level = 1 } } ch == ' ' { bracket level += 1 } ch == ' ' { bracket level = 1 } } { ch == delimiter { delimiter = '\0' } } } } /** * scans the data literal text * scanning stops when a character does not match or after the complete * text has been checked whichever comes first * * @param literal the literal to check * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>literal != null</code> * </ul></dd></dl> */ check literal literal i o { length = literal length i = 0 i < length i += 1 { read != literal at i { } } } /** * reads a character from a reader */ read i o { read too much != '\0' { ch = read too much read too much = '\0' ch } { i = reader read i < 0 { unexpected end of data } i == 10 { parser line nr += 1 '\n' } { i } } } /** * scans an xml element * * @param elt the element that will contain the result * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li> the first lt has already been read * <li><code>elt != null</code> * </ul></dd></dl> */ scan element xml element elt i o { buffer buf = buffer scan identifier buf name = buf to elt set name name ch = scan whitespace ch != '>' ch != '/' { buf set length 0 unread ch scan identifier buf key = buf to ch = scan whitespace ch != '=' { expected input = } unread scan whitespace buf set length 0 scan buf elt set attribute key buf ch = scan whitespace } ch == '/' { ch = read ch != '>' { expected input > } } buf set length 0 ch = scan whitespace buf ch != '<' { unread ch scan p c data buf } { { ch = read ch == '!' { check c d a t a buf { scan p c data buf } { ch = scan whitespace buf ch != '<' { unread ch scan p c data buf } } } { ch != '/' || ignore whitespace { buf set length 0 } ch == '/' { unread ch } } } } buf length == 0 { ch != '/' { ch == '!' { ch = read ch != ' ' { expected input comment or element } ch = read ch != ' ' { expected input comment or element } skip comment } { unread ch xml element child = create element scan element child elt add child child } ch = scan whitespace ch != '<' { expected input < } ch = read } unread ch } { ignore whitespace { elt set content buf to trim } { elt set content buf to } } ch = read ch != '/' { expected input / } unread scan whitespace ! check literal name { expected input name } scan whitespace != '>' { expected input > } } /** * resolves an entity the name of the entity is read from the reader * the value of the entity is appended to <code>buf</code> * * @param buf where to put the entity value * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li> the first amp has already been read * <li><code>buf != null</code> * </ul></dd></dl> */ resolve entity buffer buf i o { ch = '\0' buffer key buf = buffer { ch = read ch == ' ' { } key buf append ch } key = key buf to key at 0 == '#' { { key at 1 == 'x' { ch = parse key substring 2 16 } { ch = parse key substring 1 10 } } number format e { unknown entity key } buf append ch } { value = entities get key value == { unknown entity key } buf append value } } /** * pushes a character back to the read back buffer * * @param ch the character to push back * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li> the read back buffer is empty * <li><code>ch != '\0'</code> * </ul></dd></dl> */ unread ch { read too much = ch } /** * creates a parse when an invalid valueset is given to * a * * @param name the name of the entity * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * </ul></dd></dl> */ xml parse invalid value set name { msg = invalid value set entity name = \ + name + \ xml parse get name parser line nr msg } /** * creates a parse when an invalid value is given to a * * * @param name the name of the entity * @param value the value of the entity * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>value != null</code> * </ul></dd></dl> */ xml parse invalid value name value { msg = attribute \ + name + \ does not contain a valid + value \ + value + \ xml parse get name parser line nr msg } /** * creates a parse when the end of the data input has been * reached */ xml parse unexpected end of data { msg = unexpected end of data reached xml parse get name parser line nr msg } /** * creates a parse when a syntax occured * * @param context the context in which the occured * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>context != null</code> * <li><code>context length 0</code> * </ul></dd></dl> */ xml parse syntax context { msg = syntax parsing + context xml parse get name parser line nr msg } /** * creates a parse when the next character read is not * the character that was expected * * @param set the set of characters in human readable form that was * expected * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>char set != null</code> * <li><code>char set length 0</code> * </ul></dd></dl> */ xml parse expected input set { msg = expected + set xml parse get name parser line nr msg } /** * creates a parse when an entity could not be resolved * * @param name the name of the entity * * </dl><dl><dt><b> preconditions </b></dt><dd> * <ul><li><code>name != null</code> * <li><code>name length 0</code> * </ul></dd></dl> */ xml parse unknown entity name { msg = unknown or invalid entity + name + xml parse get name parser line nr msg } } 
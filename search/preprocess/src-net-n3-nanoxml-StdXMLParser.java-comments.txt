/* std xml parser nano xml/ * * $ revision 1 5 $ * $ date 2002/03/24 11 37 00 $ * $ name r e l e a s e 2 2 1 $ * * is part of nano xml 2 * copyright c 2000 2002 marc de scheemaecker all rights reserved * * software is provided 'as is' without any express or implied warranty * in no event will the authors be held liable any damages arising from the * use of software * * permission is granted to anyone to use software any purpose * including commercial applications and to alter it and redistribute it * freely subject to the following restrictions * * 1 the origin of software must not be misrepresented you must not * claim that you wrote the original software you use software in * a product an acknowledgment in the product documentation would be * appreciated but is not required * * 2 altered source versions must be plainly marked as such and must not be * misrepresented as being the original software * * 3 notice may not be removed or altered from any source distribution */package net n3 nanoxml io i o io reader io reader enumeration properties vector /** * std xml parser is the core parser of nano xml * * @author marc de scheemaecker * @version $ name r e l e a s e 2 2 1 $ $ revision 1 5 $ */public std xml parser i xml parser{ /** * the builder which creates the logical structure of the xml data */ i xml builder builder /** * the reader from which the parser retrieves its data */ i xml reader reader /** * the entity resolver */ i xml entity resolver entity resolver /** * the validator that will process entity references and validate the xml * data */ i xml validator validator /** * creates a parser */ std xml parser { builder = validator = reader = entity resolver = xml entity resolver } /** * cleans up the when it's destroyed */ finalize throwable { builder = reader = entity resolver = validator = finalize } /** * sets the builder which creates the logical structure of the xml data * * @param builder the non builder */ set builder i xml builder builder { builder = builder } /** * the builder which creates the logical structure of the xml data * * @return the builder */ i xml builder get builder { builder } /** * sets the validator that validates the xml data * * @param validator the non validator */ set validator i xml validator validator { validator = validator } /** * the validator that validates the xml data * * @return the validator */ i xml validator get validator { validator } /** * sets the entity resolver * * @param resolver the non resolver */ set resolver i xml entity resolver resolver { entity resolver = resolver } /** * the entity resolver * * @return the non resolver */ i xml entity resolver get resolver { entity resolver } /** * sets the reader from which the parser retrieves its data * * @param reader the reader */ set reader i xml reader reader { reader = reader } /** * the reader from which the parser retrieves its data * * @return the reader */ i xml reader get reader { reader } /** * parses the data and lets the builder create the logical data structure * * @return the logical structure built by the builder * * @throws net n3 nanoxml xml *		if an occurred reading or parsing the data */ parse xml { { builder start building reader get reader get line nr scan data builder get result } xml e { e } e { xml = xml e init cause e xml e } } /** * scans the xml data elements * * @throws * something went wrong */ scan data { ! reader at e o f builder get result == { str = xml read reader ' ' ch = str at 0 ch == ' ' { xml process entity str reader entity resolver } ch { '<' scan some tag don't allow c d a t a no namespace properties ' ' '\t' '\r' '\n' skip whitespace xml invalid input reader get reader get line nr ` + ch + ' 0x + to hex ch + ' ' } } } /** * scans an xml tag * * @param allow c d a t a c d a t a sections are allowed at point * @param namespace the namespace u r i or * @param namespaces list of defined namespaces * * @throws * something went wrong */ scan some tag allow c d a t a namespace properties namespaces { str = xml read reader ' ' ch = str at 0 ch == ' ' { xml unexpected entity reader get reader get line nr str } ch { '?' process p i '!' process special tag allow c d a t a reader unread ch process element namespace namespaces } } /** * processes a processing instruction * * @throws * something went wrong */ process p i { xml skip whitespace reader target = xml scan identifier reader xml skip whitespace reader reader reader = p i reader reader ! target equals ignore xml { builder processing instruction target reader } reader close } /** * processes a tag that starts with a bang lt ! * * @param allow c d a t a c d a t a sections are allowed at point * * @throws * something went wrong */ process special tag allow c d a t a { str = xml read reader ' ' ch = str at 0 ch == ' ' { xml unexpected entity reader get reader get line nr str } ch { ' ' allow c d a t a { process c d a t a } { xml unexpected c d a t a reader get reader get line nr } ' d' process doc type ' ' xml skip comment reader } } /** * processes a c d a t a section * * @throws * something went wrong */ process c d a t a { ! xml check literal reader c d a t a { xml expected input reader get reader get line nr <! c d a t a } validator p c data added reader get reader get line nr reader reader = c d a t a reader reader builder add p c data reader reader get reader get line nr reader close } /** * processes a document type declaration * * @throws *		if an occurred reading or parsing the data */ process doc type { ! xml check literal reader o c t y p e { xml expected input reader get reader get line nr <! d o c t y p e } xml skip whitespace reader = buffer = buffer root element = xml scan identifier reader xml skip whitespace reader ch = reader read ch == ' p' { = xml scan reader xml skip whitespace reader ch = reader read } ch == ' s' { = xml scan reader xml skip whitespace reader ch = reader read } ch == ' ' { validator parse d t d to reader entity resolver xml skip whitespace reader ch = reader read } ch != '>' { xml expected input reader get reader get line nr `>' } b e g i n p a t c h w randelshofer don't read d t d { != { reader reader = reader open stream to reader start stream reader reader set reader set to validator parse d t d to reader entity resolver } } e n d p a t c h w randelshofer don't read d t d } /** * processes a regular element * * @param namespace the namespace u r i or * @param namespaces list of defined namespaces * * @throws * something went wrong */ process element namespace properties namespaces { full name = xml scan identifier reader name = full name xml skip whitespace reader prefix = colon index = name index of ' ' colon index > 0 { prefix = name substring 0 colon index name = name substring colon index + 1 } vector attr names = vector vector attr values = vector vector attr types = vector validator element started full name reader get reader get line nr ch { ch = reader read ch == '/' || ch == '>' { } reader unread ch process attribute attr names attr values attr types xml skip whitespace reader } properties extra attributes = properties validator element attributes processed full name extra attributes reader get reader get line nr enumeration enm = extra attributes keys enm has more elements { key = enm next element value = extra attributes get property key attr names add element key attr values add element value attr types add element c d a t a } i = 0 i < attr names size i++ { key = attr names element at i value = attr values element at i type = attr types element at i key equals xmlns { namespace = value } key starts with xmlns { namespaces put key substring 6 value } } prefix == { builder start element name prefix namespace reader get reader get line nr } { builder start element name prefix namespaces get property prefix reader get reader get line nr } i = 0 i < attr names size i++ { key = attr names element at i key starts with xmlns { } value = attr values element at i type = attr types element at i colon index = key index of ' ' colon index > 0 { att prefix = key substring 0 colon index key = key substring colon index + 1 builder add attribute key att prefix namespaces get property att prefix value type } { builder add attribute key value type } } prefix == { builder element attributes processed name prefix namespace } { builder element attributes processed name prefix namespaces get property prefix } ch == '/' { reader read != '>' { xml expected input reader get reader get line nr `>' } validator element ended name reader get reader get line nr prefix == { builder end element name prefix namespace } { builder end element name prefix namespaces get property prefix } } buffer buffer = buffer 16 { buffer set length 0 str { xml skip whitespace reader buffer str = xml read reader ' ' str at 0 == ' ' str at 1 != '#' { xml process entity str reader entity resolver } { } } str at 0 == '<' { str = xml read reader '\0' str at 0 == '/' { xml skip whitespace reader str = xml scan identifier reader ! str equals full name { xml wrong closing tag reader get reader get line nr name str } xml skip whitespace reader reader read != '>' { xml closing tag not empty reader get reader get line nr } validator element ended full name reader get reader get line nr prefix == { builder end element name prefix namespace } { builder end element name prefix namespaces get property prefix } } { < ^/ reader unread str at 0 scan some tag c d a t a allowed namespace properties namespaces clone } } { ^< str at 0 == ' ' { ch = xml process literal str buffer append ch } { reader unread str at 0 } validator p c data added reader get reader get line nr reader r = content reader reader entity resolver buffer to builder add p c data r reader get reader get line nr r close } } } /** * processes an attribute of an element * * @param attr names contains the names of the attributes * @param attr values contains the values of the attributes * @param attr types contains the types of the attributes * * @throws * something went wrong */ process attribute vector attr names vector attr values vector attr types { key = xml scan identifier reader xml skip whitespace reader ! xml read reader ' ' equals = { xml expected input reader get reader get line nr `=' } xml skip whitespace reader value = xml scan reader ' ' entity resolver attr names add element key attr values add element value attr types add element c d a t a validator attribute added key value reader get reader get line nr }} 
/* * @ # s v g group 1 0 july 8 2006 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * */package samples svg figures geom * io * * draw * samples svg * xml * /** * s v g group * * @author werner randelshofer * @version 1 0 july 8 2006 created */public s v g group group figure s v g figure { /** creates a instance */ s v g group { s v g set defaults } @ override linked list< handle> create handles detail level { linked list< handle> handles detail level == 0 { handles = linked list< handle> create handles detail level handles add rotate handle } { handles = linked list< handle> } handles } @ override read dom input in i o { read attributes in i=0 n = in get element count i < n i++ { in open element i name = in get tag name name equals pattern { we ignore pattern elements now in close element } name equals color profile { we ignore pattern elements now in close element } name equals defs { we ignore defs elements now in close element } name equals use { we ignore use elements now in close element } name equals script { we ignore script elements now in close element } name equals filter { we ignore filter elements now in close element } name equals title { we ignore title elements now in close element } name equals desc { we ignore desc elements now in close element } name equals { we ignore elements now in close element } name equals radial gradient { we ignore radial gradient elements now in close element } name equals linear gradient { we ignore linear gradient elements now in close element } { in close element f = in read i f s v g drawing { s v g group g = s v g group g will change figure child s v g drawing f get figures { g basic add child } g changed ! g is empty { add g } } f s v g figure { ! s v g figure f is empty { add s v g figure f } } { i o unexpected child +f } } } affine transform tx = s v g get transform in transform figure child get children { child basic transform tx } invalidate bounds } read attributes dom input in i o { s v g read attributes in } @ override write dom output out i o { figure child get children { out write child } write attributes out } write attributes dom output out i o { s v g write attributes out } is empty { get child count == 0 } to { builder buf = builder buf append get get name substring get get name last index of ' ' +1 buf append '@' buf append hash get child count > 0 { buf append ' ' iterator< figure> i = get children iterator i has next { figure child = i next buf append child i has next { buf append ' ' } } buf append ' ' } buf to }} 
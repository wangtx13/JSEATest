/* xml element nano xml/ * * $ revision 1 5 $ * $ date 2002/02/06 18 50 12 $ * $ name r e l e a s e 2 2 1 $ * * is part of nano xml 2 * copyright c 2000 2002 marc de scheemaecker all rights reserved * * software is provided 'as is' without any express or implied warranty * in no event will the authors be held liable any damages arising from the * use of software * * permission is granted to anyone to use software any purpose * including commercial applications and to alter it and redistribute it * freely subject to the following restrictions * * 1 the origin of software must not be misrepresented you must not * claim that you wrote the original software you use software in * a product an acknowledgment in the product documentation would be * appreciated but is not required * * 2 altered source versions must be plainly marked as such and must not be * misrepresented as being the original software * * 3 notice may not be removed or altered from any source distribution */package net n3 nanoxml io serializable * /** * xml element is an xml element the standard nano xml builder generates a * tree of such iterator * * @see net n3 nanoxml std xml builder * * @author marc de scheemaecker * @version $ name r e l e a s e 2 2 1 $ $ revision 1 5 $ */public xml element i xml element serializable { /** * necessary serialization */ serial u = 2383376380548624920 l /** * no line number defined */ n o l i n e = 1 /** * the parent element */ i xml element parent /** * the attributes of the element */ list attributes /** * the child iterator */ list children /** * the name of the element */ name /** * the full name of the element */ full name /** * the namespace u r i */ namespace /** * the content of the element */ content /** * the of the source data where element is located */ /** * the line in the source data where element starts */ line nr /** * creates an empty element to be used # p c d a t a content */ xml element { n o l i n e } /** * creates an empty element * * @param full name the name of the element */ xml element full name { full name n o l i n e } /** * creates an empty element * * @param full name the name of the element * @param the of the xml data where the element starts * @param line nr the line in the xml data where the element starts */ xml element full name line nr { full name line nr } /** * creates an empty element * * @param full name the full name of the element * @param namespace the namespace u r i */ xml element full name namespace { full name namespace n o l i n e } /** * creates an empty element * * @param full name the full name of the element * @param namespace the namespace u r i * @param the of the xml data where the element starts * @param line nr the line in the xml data where the element starts */ xml element full name namespace line nr { attributes = list children = list 8 full name = full name namespace == { name = full name } { index = full name index of ' ' index >= 0 { name = full name substring index + 1 } { name = full name } } namespace = namespace content = line nr = line nr = parent = } /** * creates an element to be used # p c d a t a content */ i xml element create p c data element { xml element } /** * creates an empty element * * @param full name the name of the element */ i xml element create element full name { xml element full name } /** * creates an empty element * * @param full name the name of the element * @param the of the xml data where the element starts * @param line nr the line in the xml data where the element starts */ i xml element create element full name line nr { xml element full name line nr } /** * creates an empty element * * @param full name the full name of the element * @param namespace the namespace u r i */ i xml element create element full name namespace { xml element full name namespace } /** * creates an empty element * * @param full name the full name of the element * @param namespace the namespace u r i * @param the of the xml data where the element starts * @param line nr the line in the xml data where the element starts */ i xml element create element full name namespace line nr { xml element full name namespace line nr } /** * cleans up the when it's destroyed */ finalize throwable { attributes clear attributes = children = full name = name = namespace = content = = parent = finalize } /** * the parent element the root * element */ i xml element get parent { parent } /** * the full name i e the name including an eventual namespace * prefix of the element * * @return the name or the element only contains # p c d a t a */ get full name { full name } /** * the name of the element * * @return the name or the element only contains # p c d a t a */ get name { name } /** * the namespace of the element * * @return the namespace or no namespace is associated with the * element */ get namespace { namespace } /** * sets the full name also sets the name and clears the * namespace u r i * * @param name the non name */ set name name { name = name full name = name namespace = } /** * sets the name * * @param full name the non full name * @param namespace the namespace u r i which may be */ set name full name namespace { index = full name index of ' ' namespace == || index < 0 { name = full name } { name = full name substring index + 1 } full name = full name namespace = namespace } /** * adds a child element * * @param child the non child to add */ add child i xml element child { child == { illegal argument child must not be } child get name == ! children is empty { i xml element last child = i xml element children get children size 1 last child get name == { last child set content last child get content + child get content } } xml element child parent = children add child } /** * inserts a child element * * @param child the non child to add * @param index where to put the child */ insert child i xml element child index { child == { illegal argument child must not be } child get name == ! children is empty { i xml element last child = i xml element children get children size 1 last child get name == { last child set content last child get content + child get content } } xml element child parent = children add index child } /** * removes a child element * * @param child the non child to remove */ remove child i xml element child { child == { illegal argument child must not be } children remove child } /** * removes the child located at a certain index * * @param index the index of the child where the first child has index 0 */ remove child at index index { children remove index } /** * an enumeration of all child iterator * * @return the non enumeration */ iterator iterate children { children iterator } /** * whether the element is a leaf element * * @return the element has no children */ is leaf { children is empty } /** * whether the element has children * * @return the element has children */ has children { ! children is empty } /** * the number of children * * @return the count */ get children count { children size } /** * a vector containing all the child iterator * * @return the vector */ list get children { children } /** * the child at a specific index * * @param index the index of the child * * @return the non child * * @throws index out of bounds *		if the index is out of bounds */ i xml element get child at index index index out of bounds { i xml element children get index } /** * searches a child element * * @param name the full name of the child to search * * @return the child element or no such child was found */ i xml element get first child named name { iterator enm = children iterator enm has next { i xml element child = i xml element enm next child name = child get full name child name != child name equals name { child } } } /** * searches a child element * * @param name the name of the child to search * @param namespace the namespace which may be * * @return the child element or no such child was found */ i xml element get first child named name namespace { iterator enm = children iterator enm has next { i xml element child = i xml element enm next str = child get name found = str != str equals name str = child get namespace str == { found = name == } { found = str equals namespace } found { child } } } /** * a vector of all child iterator named < i>name</ i> * * @param name the full name of the children to search * * @return the non vector of child iterator */ list get children named name { list result = list children size iterator enm = children iterator enm has next { i xml element child = i xml element enm next child name = child get full name child name != child name equals name { result add child } } result } /** * a vector of all child iterator named < i>name</ i> * * @param name the name of the children to search * @param namespace the namespace which may be * * @return the non vector of child iterator */ list get children named name namespace { list result = list children size iterator enm = children iterator enm has next { i xml element child = i xml element enm next str = child get name found = str != str equals name str = child get namespace str == { found = name == } { found = str equals namespace } found { result add child } } result } /** * searches an attribute * * @param full name the non full name of the attribute * * @return the attribute or the attribute does not */ xml attribute find attribute full name { iterator enm = attributes iterator enm has next { xml attribute attr = xml attribute enm next attr get full name equals full name { attr } } } /** * searches an attribute * * @param name the non name of the attribute * @param namespace the name space which may be * * @return the attribute or the attribute does not */ xml attribute find attribute name namespace { iterator enm = attributes iterator enm has next { xml attribute attr = xml attribute enm next found = attr get name equals name namespace == { found = attr get namespace == } { found = namespace equals attr get namespace } found { attr } } } /** * the number of attributes */ get attribute count { attributes size } /** * @deprecated as of nano xml/ 2 1 replaced by * {@link #get attribute } * the value of an attribute * * @param name the non name of the attribute * * @return the value or the attribute does not */ get attribute name { get attribute name } /** * the value of an attribute * * @param name the non full name of the attribute * @param value the value of the attribute * * @return the value or value the attribute does not */ get attribute name value { xml attribute attr = find attribute name attr == { value } { attr get value } } /** * the value of an attribute * * @param name the non name of the attribute * @param namespace the namespace u r i which may be * @param value the value of the attribute * * @return the value or value the attribute does not */ get attribute name namespace value { xml attribute attr = find attribute name namespace attr == { value } { attr get value } } /** * the value of an attribute * * @param name the non full name of the attribute * @param value the value of the attribute * * @return the value or value the attribute does not */ get attribute name value { value = get attribute name to value parse value } /** * the value of an attribute * * @param name the non name of the attribute * @param namespace the namespace u r i which may be * @param value the value of the attribute * * @return the value or value the attribute does not */ get attribute name namespace value { value = get attribute name namespace to value parse value } /** * the type of an attribute * * @param name the non full name of the attribute * * @return the type or the attribute does not */ get attribute type name { xml attribute attr = find attribute name attr == { } { attr get type } } /** * the namespace of an attribute * * @param name the non full name of the attribute * * @return the namespace or there is none associated */ get attribute namespace name { xml attribute attr = find attribute name attr == { } { attr get namespace } } /** * the type of an attribute * * @param name the non name of the attribute * @param namespace the namespace u r i which may be * * @return the type or the attribute does not */ get attribute type name namespace { xml attribute attr = find attribute name namespace attr == { } { attr get type } } /** * sets an attribute * * @param name the non full name of the attribute * @param value the non value of the attribute */ set attribute name value { xml attribute attr = find attribute name attr == { attr = xml attribute name name value c d a t a attributes add attr } { attr set value value } } /** * sets an attribute * * @param full name the non full name of the attribute * @param namespace the namespace u r i of the attribute which may be * @param value the non value of the attribute */ set attribute full name namespace value { index = full name index of ' ' name = full name substring index + 1 xml attribute attr = find attribute name namespace attr == { attr = xml attribute full name name namespace value c d a t a attributes add attr } { attr set value value } } /** * removes an attribute * * @param name the non name of the attribute */ remove attribute name { i = 0 i < attributes size i++ { xml attribute attr = xml attribute attributes get i attr get full name equals name { attributes remove i } } } /** * removes an attribute * * @param name the non name of the attribute * @param namespace the namespace u r i of the attribute which may be */ remove attribute name namespace { i = 0 i < attributes size i++ { xml attribute attr = xml attribute attributes get i found = attr get name equals name namespace == { found = attr get namespace == } { found = attr get namespace equals namespace } found { attributes remove i } } } /** * an enumeration of all attribute names * * @return the non enumeration */ iterator iterate attribute names { list result = list iterator enm = attributes iterator enm has next { xml attribute attr = xml attribute enm next result add attr get full name } result iterator } /** * whether an attribute * * @return the attribute */ has attribute name { find attribute name != } /** * whether an attribute * * @return the attribute */ has attribute name namespace { find attribute name namespace != } /** * all attributes as a properties * * @return the non set */ properties get attributes { properties result = properties iterator enm = attributes iterator enm has next { xml attribute attr = xml attribute enm next result put attr get full name attr get value } result } /** * all attributes in a specific namespace as a properties * * @param namespace the namespace u r i of the attributes which may be * * @return the non set */ properties get attributes in namespace namespace { properties result = properties iterator enm = attributes iterator enm has next { xml attribute attr = xml attribute enm next namespace == { attr get namespace == { result put attr get name attr get value } } { namespace equals attr get namespace { result put attr get name attr get value } } } result } /** * the of the data where the element started * * @return the or unknown * * @see #get line nr */ get { } /** * the line number in the data where the element started * * @return the line number or n o l i n e unknown * * @see # n o l i n e * @see #get */ get line nr { line nr } /** * the # p c d a t a content of the element the element has a * combination of # p c d a t a content and child iterator the # p c d a t a * sections can be retrieved as unnamed child in * * * @return the content */ get content { content } /** * sets the # p c d a t a content it is an to call with a * non value there are child * * @param content the possibly content */ set content content { content = content } /** * the element equals another element * * @param raw element the element to compare to */ equals raw element { { equals xml element i xml element raw element } cast e { } } /** * the element equals another element * * @param raw element the element to compare to */ equals xml element i xml element elt { ! name equals elt get name { } attributes size != elt get attribute count { } iterator enm = attributes iterator enm has next { xml attribute attr = xml attribute enm next ! elt has attribute attr get name attr get namespace { } value = elt get attribute attr get name attr get namespace ! attr get value equals value { } type = elt get attribute type attr get name attr get namespace ! attr get type equals type { } } children size != elt get children count { } i = 0 i < children size i++ { i xml element child1 = get child at index i i xml element child2 = elt get child at index i ! child1 equals xml element child2 { } } }} 
/* * @ # stroke 1 0 2006 06 18 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * */package geom * geom * font * /** * draws a stroke an outline of an outline * the inner width of a stroke defines the distance between the two * outlines being drawn the outline width of a stroke defines the * thickness of the outline * * @author werner randelshofer * @version 1 0 2006 06 18 fixed bugs * <br>1 0 21 march 2006 created */public stroke stroke { basic stroke outline stroke inner width outline width miter limit dashes dash phase stroke inner width outline width { inner width outline width basic stroke c a p s q u a r e basic stroke j o i n b e v e l 10f 0f } stroke inner width outline width cap join miter limit dashes dash phase { inner width = inner width outline width = outline width miter limit = miter limit outline stroke = basic stroke outline width cap join miter limit dashes dash phase outline stroke = basic stroke outline width cap basic stroke j o i n b e v e l miter limit dashes dash phase } shape create stroked shape shape s { bezier path bp = bezier path general path left = general path general path right = general path coords = 6 f i x m e we only a flattened path path iterator i = s get path iterator 0 1d ! i is done i next { type = i current segment coords type { path iterator s e g m o v e t o bp size != 0 { trace stroke bp left right } bp clear bp set closed bp move to coords 0 coords 1 path iterator s e g l i n e t o coords 0 != bp get bp size 1 x 0 || coords 1 != bp get bp size 1 y 0 { bp line to coords 0 coords 1 } path iterator s e g q u a d t o bp quad to coords 0 coords 1 coords 2 coords 3 path iterator s e g c u b i c t o bp curve to coords 0 coords 1 coords 2 coords 3 coords 4 coords 5 path iterator s e g c l o s e bp set closed } } bp size != 0 { trace stroke bp left right } note could be extended to use different stroke the inner and the outher path right append left outline stroke create stroked shape right } trace stroke bezier path bp general path left general path right { x x x we only support straight line segments here corners of the current and the previous thick line current corners = 8 prev corners = 8 point2 d intersect remove duplicate nodes from bezier path bp is closed { bezier path node prev = bp get bp size 1 i=0 i < bp size i++ { bezier path node node = bp get i prev x 0 == node x 0 prev y 0 == node y 0 { bp remove i } { prev = node } } } { bezier path node prev = bp get 0 i=1 i < bp size i++ { bezier path node node = bp get i prev x 0 == node x 0 prev y 0 == node y 0 { bp remove i } { prev = node } } } handle the first point of the bezier path bp is closed bp size > 1 { prev corners = compute thick line bp get bp size 1 x 0 bp get bp size 1 y 0 bp get 0 x 0 bp get 0 y 0 inner width prev corners current corners = compute thick line bp get 0 x 0 bp get 0 y 0 bp get 1 x 0 bp get 1 y 0 inner width current corners intersect = geom intersect prev corners 0 prev corners 1 prev corners 4 prev corners 5 current corners 0 current corners 1 current corners 4 current corners 5 miter limit intersect != { right move to intersect x intersect y } { right move to prev corners 4 prev corners 5 right line to current corners 0 current corners 1 } intersect = geom intersect prev corners 2 prev corners 3 prev corners 6 prev corners 7 current corners 2 current corners 3 current corners 6 current corners 7 miter limit intersect != { left move to intersect x intersect y } { left move to prev corners 6 prev corners 7 left line to current corners 2 current corners 3 } } { bp size > 1 { current corners = compute thick line bp get 0 x 0 bp get 0 y 0 bp get 1 x 0 bp get 1 y 0 inner width current corners right move to current corners 0 current corners 1 left move to current corners 2 current corners 3 } } handle points in the middle of the bezier path i=1 n = bp size 1 i < n i++ { tmp = prev corners prev corners = current corners current corners = compute thick line bp get i x 0 bp get i y 0 bp get i+1 x 0 bp get i+1 y 0 inner width tmp intersect = geom intersect prev corners 0 prev corners 1 prev corners 4 prev corners 5 current corners 0 current corners 1 current corners 4 current corners 5 miter limit intersect != { right line to intersect x intersect y } { right line to prev corners 4 prev corners 5 right line to current corners 0 current corners 1 } intersect = geom intersect prev corners 2 prev corners 3 prev corners 6 prev corners 7 current corners 2 current corners 3 current corners 6 current corners 7 miter limit intersect != { left line to intersect x intersect y } { left line to prev corners 6 prev corners 7 left line to current corners 2 current corners 3 } } handle the last point of the bezier path bp is closed { tmp = prev corners prev corners = current corners current corners = compute thick line bp get bp size 1 x 0 bp get bp size 1 y 0 bp get 0 x 0 bp get 0 y 0 bp get 1 x 0 bp get 1 y 0 inner width tmp intersect = geom intersect prev corners 0 prev corners 1 prev corners 4 prev corners 5 current corners 0 current corners 1 current corners 4 current corners 5 miter limit intersect != { right line to intersect x intersect y } { right line to prev corners 4 prev corners 5 right line to current corners 0 current corners 1 } intersect = geom intersect prev corners 2 prev corners 3 prev corners 6 prev corners 7 current corners 2 current corners 3 current corners 6 current corners 7 miter limit intersect != { left line to intersect x intersect y } { left line to prev corners 6 prev corners 7 left line to current corners 2 current corners 3 } right close path left close path } { right line to current corners 4 current corners 5 left line to current corners 6 current corners 7 } } compute thick line seg offset corners { compute thick line seg 0+offset seg 1+offset seg 2+offset seg 3+offset inner width corners } compute thick line x1 y1 x2 y2 thickness corners { dx = x2 x1 dy = y2 y1 line length line length = math sqrt dx * dx + dy * dy scale = thickness / 2d * line length the x and y increments from an endpoint needed to create a rectangle ddx = scale * dy ddy = scale * dx /* ddx += ddx > 0 ? 0 5 0 5 ddy += ddy > 0 ? 0 5 0 5 */ now we can compute the corner points corners 0 = x1 + ddx corners 1 = y1 + ddy corners 2 = x1 ddx corners 3 = y1 ddy corners 4 = x2 + ddx corners 5 = y2 + ddy corners 6 = x2 ddx corners 7 = y2 ddy corners }} 
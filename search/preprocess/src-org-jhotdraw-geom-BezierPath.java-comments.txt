/* * @ # bezier path 1 1 2006 03 22 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * */package geom * geom * * /** * bezier path allows the construction of paths consisting of straight lines * quadratic curves and cubic curves * <p> * a bezier path represents a geometric path constructed by vertices * each node has three control points c0 c1 c2 * a mask defines which control points are in use the path passes through * c0 c1 controls the curve going towards c0 c2 controls the curve going * away from c0 * * @author werner randelshofer * @version 1 1 2006 03 22 move to line to and quad to added * <br>1 0 january 20 2006 created */public bezier path list< bezier path node> shape { /** constant control point c1 * */ c1 m a s k = 1 /** constant control point c2 */ c2 m a s k = 2 /** convenience constant control point c1 and c2 */ c1 c2 m a s k = c1 m a s k | c2 m a s k /** * we cache a general path instance to speed up shape operations */ general path general path /** * we cache the index of the outermost node to speed up index of outermost node */ outer = 1 /** * value is set to closes the bezier path */ is closed /** * defines a vertex node of the bezier path * <p> * a vertex consists of three control points c0 c1 and c2 * <ul> * <li> the bezier path always passes through c0 </li> * <li> c1 is used to control the curve towards c0 * </li> * <li> c2 is used to control the curve going away from c0 </li> * </ul> */ node cloneable { /** * mask is used to describe which control points in addition to * c0 are in effect */ mask = 0 /** control point x coordinates */ x = 3 /** control point y coordinates */ y = 3 /** is a hint editing tools is set to * the editing tools shall keep all control points on the same * line */ keep colinear = node { mask = 1 } node node that { set to that } set to node that { mask = that mask keep colinear = that keep colinear arraycopy that x 0 x 0 3 arraycopy that y 0 y 0 3 } node point2 d c0 { mask = 0 x 0 = c0 x y 0 = c0 y x 1 = c0 x y 1 = c0 y x 2 = c0 x y 2 = c0 y } node mask point2 d c0 point2 d c1 point2 d c2 { mask = mask x 0 = c0 x y 0 = c0 y x 1 = c1 x y 1 = c1 y x 2 = c2 x y 2 = c2 y } node x0 y0 { mask = 0 x 0 = x0 y 0 = y0 x 1 = x0 y 1 = y0 x 2 = x0 y 2 = y0 } node mask x0 y0 x1 y1 x2 y2 { mask = mask x 0 = x0 y 0 = y0 x 1 = x1 y 1 = y1 x 2 = x2 y 2 = y2 } get mask { mask } set mask value { mask = value } set control point index point2 d p { x index = p x y index = p y } point2 d get control point index { point2 d x index y index } move to point2 d p { move by p x x 0 p y y 0 } move to x y { move by x x 0 y y 0 } move by dx dy { i=0 i < 3 i++ { x i += dx y i += dy } } clone { { node that = node clone that x = x clone that y = y clone that } clone not supported e { internal = internal init cause e } } to { builder buf = builder buf append ' ' i=0 i < 3 i++ { i != 0 { mask i == i { buf append ' ' } { } } buf append 'x' buf append i buf append '=' buf append x i buf append y buf append i buf append '=' buf append y i } buf append ' ' buf to } } /** creates a instance */ bezier path { } /** * convenience adding a control point with a single * coordinate c0 */ add point2 d c0 { add node 0 c0 c0 c0 } add point x y { add node 0 x y x y x y } /** * convenience adding a control point with three * coordinates c0 c1 and c2 with a mask */ add mask point2 d c0 point2 d c1 point2 d c2 { add node mask c0 c1 c2 } /** * convenience changing a single coordinate of a control point */ set index coord point2 d p { node c = get index c x coord = p x c y coord = p y } /** * convenience getting a single coordinate of a control point */ point2 d get index coord { node c = get index point2 d c x coord c y coord } /** * must be called after the bezier path has been changed */ invalidate path { general path = outer = 1 } /** * recomputes the bezier path it is invalid */ validate path { general path == { general path = to general path } } /** converts the bezier path into a general path */ general path to general path { general path gp = general path gp set winding rule general path w i n d e v e n o d d size == 0 { gp move to 0 0 gp line to 0 0 + 1 } size == 1 { node current = get 0 gp move to current x 0 current y 0 gp line to current x 0 current y 0 + 1 } { node previous node current previous = current = get 0 gp move to current x 0 current y 0 i=1 n = size i < n i++ { previous = current current = get i previous mask c2 m a s k == 0 { current mask c1 m a s k == 0 { gp line to current x 0 current y 0 } { gp quad to current x 1 current y 1 current x 0 current y 0 } } { current mask c1 m a s k == 0 { gp quad to previous x 2 previous y 2 current x 0 current y 0 } { gp curve to previous x 2 previous y 2 current x 1 current y 1 current x 0 current y 0 } } } is closed { size > 1 { previous = get size 1 current = get 0 previous mask c2 m a s k == 0 { current mask c1 m a s k == 0 { gp line to current x 0 current y 0 } { gp quad to current x 1 current y 1 current x 0 current y 0 } } { current mask c1 m a s k == 0 { gp quad to previous x 2 previous y 2 current x 0 current y 0 } { gp curve to previous x 2 previous y 2 current x 1 current y 1 current x 0 current y 0 } } } gp close path } } gp } contains point2 d p { validate path general path contains p } /** * the outline of bezier path contains the specified * point * * @param p the point to be tested * @param tolerance the tolerance the test */ outline contains point2 d p tolerance { validate path path iterator i = general path get path iterator affine transform tolerance coords = 6 type = i current segment coords prev x = coords 0 prev y = coords 1 i next ! i is done { i current segment coords geom line contains point prev x prev y coords 0 coords 1 p x p y tolerance { } prev x = coords 0 prev y = coords 1 i next } } intersects rectangle2 d r { validate path general path intersects r } path iterator get path iterator affine transform at { validate path general path get path iterator at } contains rectangle2 d r { validate path general path contains r } path iterator get path iterator affine transform at flatness { validate path general path get path iterator at flatness } intersects x y w h { validate path general path intersects x y w h } rectangle2 d get bounds2 d { validate path general path get bounds2 d } rectangle2 d get bounds2 d { validate path rectangle2 d r = general path get bounds2 d r rectangle2 d { rectangle2 d r } { rectangle2 d r get x r get y r get width r get height } } rectangle get bounds { validate path general path get bounds } contains x y w h { validate path general path contains x y w h } contains x y { validate path general path contains x y } set closed value { is closed != value { is closed = value invalidate path } } is closed { is closed } /** creates a deep copy of the bezier path */ clone { bezier path that = bezier path clone i=0 n = size i < n i++ { that set i node get i clone } that } /** * transforms the bezier path * @param tx the transformation */ transform affine transform tx { point2 d p = point2 d node cp { i=0 i < 3 i++ { p x = cp x i p y = cp y i tx transform p p cp x i = p x cp y i = p y } } invalidate path } set to bezier path that { that size < size { remove size 1 } i=0 n = size i < n i++ { get i set to that get i } size < that size { add node that get size clone } } /** * the point at the center of the bezier path */ point2 d get center { sx = 0 sy = 0 node p { sx += p x 0 sy += p y 0 } n = size point2 d sx / n sy / n } /** * a point on the edge of the bezier path which crosses the line * from the center of the bezier path to the specified point * no edge crosses the line the nearest c0 control point is */ point2 d chop point2 d p { validate path geom chop general path p /* point2 d ctr = get center chopped point cx = 1 cy = 1 len = m a x v a l u e points along edge validate path path iterator i = general path get path iterator affine transform 1 coords = 6 type = i current segment coords prev x = coords 0 prev y = coords 1 i next ! i is done i next { i current segment coords point2 d chop = geom intersect prev x prev y coords 0 coords 1 p x p y ctr x ctr y chop != { cl = geom length2 chop x chop y p x p y cl < len { len = cl cx = chop x cy = chop y } } prev x = coords 0 prev y = coords 1 } is closed size > 1 { node first = get 0 node last = get size 1 point2 d chop = geom intersect first x 0 first y 0 last x 0 last y 0 p x p y ctr x ctr y chop != { cl = geom length2 chop x chop y p x p y cl < len { len = cl cx = chop x cy = chop y } } } none found pick closest vertex len == m a x v a l u e { j = 0 n = size j < n j++ { node cp = get j l = geom length2 cp x 0 cp y 0 p x p y l < len { len = l cx = cp x 0 cy = cp y 0 } } } point2 d cx cy */ } /** * the index of the control point that is furthest from the center **/ index of outermost node { outer == 1 { point2 d ctr = get center outer = 0 dist = 0 i = 0 n = size i < n i++ { node cp = get i d = geom length2 ctr x ctr y cp x 0 cp y 0 d > dist { dist = d outer = i } } } outer } /** * a relative point on the path * where 0 is the start point of the path and 1 is the end point of the * path * * @param relative a value between 0 and 1 */ point2 d get point on path relative flatness { size == 0 { } size == 1 { get 0 get control point 0 } relative <= 0 { get 0 get control point 0 } relative >= 1 { get size 1 get control point 0 } validate path determine the length of the path len = 0 path iterator i = general path get path iterator affine transform flatness coords = 6 type = i current segment coords prev x = coords 0 prev y = coords 1 i next ! i is done i next { i current segment coords len += geom length prev x prev y coords 0 coords 1 prev x = coords 0 prev y = coords 1 } compute the relative point on the path relative len = len * relative pos = 0 i = general path get path iterator affine transform flatness type = i current segment coords prev x = coords 0 prev y = coords 1 i next ! i is done i next { i current segment coords seg len = geom length prev x prev y coords 0 coords 1 pos + seg len >= relative len { point2 d coords 0 coords 1 compute the relative point2 d on the line /* point2 d prev x * pos / len + coords 0 * pos + seg len / len prev y * pos / len + coords 1 * pos + seg len / len */ factor = relative len pos / seg len point2 d prev x * 1 factor + coords 0 * factor prev y * 1 factor + coords 1 * factor } pos += seg len prev x = coords 0 prev y = coords 1 } internal we should never get here } /** * gets the segment of the polyline that is hit by * the given point2 d * @return the index of the segment or 1 no segment was hit */ find segment point2 d find tolerance { x x x works only straight lines! node v1 v2 bezier path temp path = bezier path node t1 t2 temp path add t1 = node temp path add t2 = node i = 0 n = size 1 i < n i++ { v1 = get i v2 = get i+1 v1 mask == 0 v2 mask == 0 { geom line contains point v1 x 0 v1 y 0 v2 x 0 v2 y 0 find x find y tolerance { i } } { t1 set to v1 t2 set to v2 temp path invalidate path temp path outline contains find tolerance { i } } } is closed size > 1 { v1 = get size 1 v2 = get 0 v1 mask == 0 v2 mask == 0 { geom line contains point v1 x 0 v1 y 0 v2 x 0 v2 y 0 find x find y tolerance { size 1 } } { t1 set to v1 t2 set to v2 temp path invalidate path temp path outline contains find tolerance { size 1 } } } 1 } /** * joins two segments into one the given point2 d hits a node * of the bezier path * @return the index of the joined segment or 1 no segment was joined */ join segments point2 d join tolerance { i=0 i < size i++ { node p = get i geom length p x 0 p y 0 join x join y < tolerance { remove i i } } 1 } /** * splits the segment at the given point2 d a segment was hit * @return the index of the segment or 1 no segment was hit */ split segment point2 d split tolerance { i = find segment split tolerance next i = i + 1 % size i != 1 { get i mask c2 m a s k == c2 m a s k get next i mask c1 m a s k == 0 { quadto add i + 1 node c2 m a s k split split split } get i mask c2 m a s k == 0 get next i mask c1 m a s k == c1 m a s k { quadto add i + 1 node c2 m a s k split split split } get i mask c2 m a s k == c2 m a s k get next i mask c1 m a s k == c2 m a s k { cubicto add i + 1 node c1 m a s k | c2 m a s k split split split } { lineto add i + 1 node split } } i+1 } move to x1 y1 { size != 0 { illegal path state move to only allowed when empty } add node x1 y1 } line to x1 y1 { size == 0 { illegal path state line to only allowed when not empty } add node x1 y1 } quad to x1 y1 x2 y2 { size == 0 { illegal path state quad to only allowed when not empty } add node c1 m a s k x2 y2 x1 y1 x2 y2 } curve to x1 y1 x2 y2 x3 y3 { size == 0 { illegal path state curve to only allowed when not empty } node last point = get size 1 last point mask |= c2 m a s k last point x 2 = x1 last point y 2 = y1 add node c1 m a s k x3 y3 x2 y2 x3 y3 } point2 d to polygon { point2 d points = point2 d size i=0 n = size i < n i++ { points i = point2 d get i x 0 get i y 0 } points } } 
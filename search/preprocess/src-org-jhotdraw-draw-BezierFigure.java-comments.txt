/* * @ # bezier figure 2 1 1 2006 06 08 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * */package draw * * event * geom * * undo * io * draw attribute keys * geom * xml dom input xml dom output /** * a bezier figure can be used to draw arbitrary shapes using a bezier path * it can be used to draw an open path or a closed shape * * @version 2 1 1 2006 06 08 fixed caps drawing * <br>2 1 2006 04 21 improved caps drawing * <br>2 0 2006 01 14 changed to support coordinates * <br>1 0 march 14 2004 * @author werner randelshofer */public bezier figure attributed figure { attribute key< boolean> c l o s e d = attribute key< boolean> closed /** * the bezier path */ bezier path path /** * the capped path bezier path is derived from variable path * we cache it to increase the drawing speed of the figure */ bezier path capped path /** creates a instance */ bezier figure { } /** creates a instance */ bezier figure is closed { path = bezier path c l o s e d set is closed path set closed is closed } d r a w i n g s h a p e a n d b o u n d s a t t r i b u t e s e d i t i n g c o n n e c t i n g /** * the figures connector the specified location * by a chop diamond connector is * @see chop diamond connector */ connector find connector point2 d p connection figure prototype { chop bezier connector } connector find compatible connector connector c is start { chop bezier connector } c o m p o s i t e f i g u r e s c l o n i n g e v e n t h a n d l i n g draw stroke graphics2 d g { is closed { grow = attribute keys get perpendicular draw growth grow == 0d { g draw path } { grow stroke gs = grow stroke grow attribute keys get stroke total width * s t r o k e m i t e r l i m i t f a c t o r get g draw gs create stroked shape path } } { g draw get capped path } draw caps g } draw caps graphics2 d g { get point count > 1 { s t a r t d e c o r a t i o n get != { bezier path cp = get capped path point2 d p1 = path get 0 0 point2 d p2 = cp get 0 0 p2 equals p1 { p2 = path get 1 0 } s t a r t d e c o r a t i o n get draw g p1 p2 } e n d d e c o r a t i o n get != { bezier path cp = get capped path point2 d p1 = path get path size 1 0 point2 d p2 = cp get path size 1 0 p2 equals p1 { p2 = path get path size 2 0 } e n d d e c o r a t i o n get draw g p1 p2 } } } draw fill graphics2 d g { is closed { grow = attribute keys get perpendicular fill growth grow == 0d { g fill path } { grow stroke gs = grow stroke grow attribute keys get stroke total width * s t r o k e m i t e r l i m i t f a c t o r get g fill gs create stroked shape path } } } contains point2 d p { is closed { grow = attribute keys get perpendicular hit growth grow == 0d { path contains p } { grow stroke gs = grow stroke grow attribute keys get stroke total width * s t r o k e m i t e r l i m i t f a c t o r get gs create stroked shape path contains p } } { tolerance = math max 2f attribute keys get stroke total width / 2 get capped path outline contains p tolerance { } s t a r t d e c o r a t i o n get != { bezier path cp = get capped path point2 d p1 = path get 0 0 point2 d p2 = cp get 0 0 f i x m e check here caps path contains the point geom line contains point p1 x p1 y p2 x p2 y p x p y tolerance { } } e n d d e c o r a t i o n get != { bezier path cp = get capped path point2 d p1 = path get path size 1 0 point2 d p2 = cp get path size 1 0 f i x m e check here caps path contains the point geom line contains point p1 x p1 y p2 x p2 y p x p y tolerance { } } } } /** * checks figure can be connected by * filled bezier figures can be connected */ can connect { is closed } collection< handle> create handles detail level { linked list< handle> handles = linked list< handle> detail level { 0 box handle kit add box handles handles handles add bezier scale handle 1 i=0 n = path size i < n i++ { handles add bezier node handle i } } handles } rectangle2 d get bounds { rectangle2 d bounds =path get bounds2 d make sure bounds are not empty bounds width = math max 1 bounds width bounds height = math max 1 bounds height bounds } rectangle2 d get figure draw bounds { rectangle2 d r = get figure draw bounds get node count > 1 { s t a r t d e c o r a t i o n get != { point2 d p1 = get point 0 0 point2 d p2 = get point 1 0 r add s t a r t d e c o r a t i o n get get draw bounds p1 p2 } e n d d e c o r a t i o n get != { point2 d p1 = get point get node count 1 0 point2 d p2 = get point get node count 2 0 r add e n d d e c o r a t i o n get get draw bounds p1 p2 } } r } validate { validate path invalidate path invalidate capped path } /** * a clone of the bezier path of figure */ bezier path get bezier path { bezier path path clone } point2 d get point on path relative flatness { path get point on path relative flatness } /** * sets the bezier path without cloning and without firing events */ basic set bezier path bezier path value { path = value set closed value is closed } is closed { get attribute c l o s e d } set closed value { c l o s e d set value } basic set attribute attribute key key value { key == c l o s e d { path set closed value } basic set attribute key value } basic set bounds point2 d anchor point2 d { basic set start point anchor basic set end point invalidate } basic transform affine transform tx { path transform tx invalidate } invalidate { invalidate path invalidate path invalidate capped path } invalidate capped path { capped path = } /** * a path which is capped path at the ends to prevent * it from drawing under the end caps */ bezier path get capped path { capped path == { capped path = bezier path path clone is closed { capped path set closed } { capped path size > 1 { s t a r t d e c o r a t i o n get != { bezier path node p0 = capped path get 0 bezier path node p1 = capped path get 1 point2 d pp p0 get mask bezier path c2 m a s k != 0 { pp = p0 get control point 2 } p1 get mask bezier path c1 m a s k != 0 { pp = p1 get control point 1 } { pp = p1 get control point 0 } radius = s t a r t d e c o r a t i o n get get decoration radius line length = geom length p0 get control point 0 pp capped path set 0 0 geom cap pp p0 get control point 0 math min radius line length } e n d d e c o r a t i o n get != { bezier path node p0 = capped path get capped path size 1 bezier path node p1 = capped path get capped path size 2 point2 d pp p0 get mask bezier path c1 m a s k != 0 { pp = p0 get control point 1 } p1 get mask bezier path c2 m a s k != 0 { pp = p1 get control point 2 } { pp = p1 get control point 0 } radius = e n d d e c o r a t i o n get get decoration radius line length = geom length p0 get control point 0 pp capped path set capped path size 1 0 geom cap pp p0 get control point 0 math min radius line length } capped path invalidate path } } } capped path } layout { } /** * adds a control point */ add node bezier path node p { add node get node count p } /** * adds a node to the list of points */ add node index bezier path node p { bezier path node point = bezier path node p will change basic add node index point layout changed fire undoable edit happened undoable edit { get presentation name { punkt einf\u00fcgen } undo cannot undo { undo will change basic remove node index changed } redo cannot undo { redo will change basic add node index point changed } } } /** * adds a control point */ basic add node bezier path node p { path add p invalidate } /** * adds a control point */ basic add node index bezier path node p { path add index p } /** * sets a control point */ set node index bezier path node p { will change bezier path node old value = path get index bezier path node value = bezier path node p basic set node index value changed fire undoable edit happened bezier node edit index old value value } /** * sets a control point */ basic set node index bezier path node p { path set index p } /** * gets a control point */ bezier path node get node index { bezier path node path get index clone } /** * convenience getting the point coordinate of * the first control point of the specified node */ point2 d get point index { path get index get control point 0 } /** * gets the point coordinate of a control point */ point2 d get point index coord { path get index get control point coord } /** * sets the point coordinate of a control point */ set point index coord point2 d p { will change basic set point index coord p changed x x x fire undoable edit event } /** * sets the point coordinate of control point 0 at the specified node */ basic set point index point2 d p { bezier path node node = path get index dx = p x node x 0 dy = p y node y 0 i=0 i < node x length i++ { node x i += dx node y i += dy } invalidate } /** * sets the point coordinate of a control point */ basic set point index coord point2 d p { bezier path node cp = bezier path node path get index cp set control point coord p basic set node index cp } /** * convenience setting the point coordinate of the start point */ basic set start point point2 d p { basic set point 0 p } /** * convenience setting the point coordinate of the end point */ basic set end point point2 d p { basic set point get point count 1 p } /** * convenience getting the start point */ point2 d get start point { get point 0 0 } /** * convenience getting the end point */ point2 d get end point { get point get node count 1 0 } /** * finds a control point index * 1 no control point could be found * f i x m e move to bezier path */ find node point2 d p { bezier path tp = path i=0 i < tp size i++ { bezier path node p2 = tp get i p2 x 0 == p x p2 y 0 == p y { i } } 1 } /** * removes all points */ remove all nodes { will change basic remove all nodes changed } /** * removes the point2 d at the specified index */ remove node index { bezier path node old point = bezier path node path get index will change basic remove node index layout changed fire undoable edit happened undoable edit { get presentation name { punkt entfernen } undo cannot undo { undo will change basic add node index old point changed } redo cannot undo { redo basic remove node index changed } } } /** * gets the segment of the polyline that is hit by * the given point2 d * @return the index of the segment or 1 no segment was hit * * x x x move to bezier path */ find segment point2 d find { fixme use path iterator point2 d p1 p2 i = 0 n = get node count 1 i < n i++ { p1 = path get i 0 p2 = path get i+1 0 geom line contains point p1 x p1 y p2 x p2 y find x find y 3d { i } } 1 } /** * joins two segments into one the given point2 d hits a node * of the polyline * @return the two segments were joined * * x x x move to bezier path */ basic join segments point2 d join { i = find segment join i != 1 i > 1 { remove node i } } /** * splits the segment at the given point2 d a segment was hit * @return the index of the segment or 1 no segment was hit * * x x x move to bezier path */ basic split segment point2 d split { i = find segment split i != 1 { add node i + 1 bezier path node split } i+1 } /** * removes the point2 d at the specified index */ basic remove node index { path remove index } /** * removes the point2 d at the specified index */ basic remove all nodes { path clear } /** * gets the node count */ get node count { path size } /** * gets the point count */ get point count { path size } bezier figure clone { bezier figure that = bezier figure clone that path = bezier path path clone that invalidate that } restore to geometry { path set to bezier path geometry } get restore data { path clone } point2 d chop point2 d p { is closed { grow = attribute keys get perpendicular hit growth grow == 0d { path chop p } { grow stroke gs = grow stroke grow attribute keys get stroke total width * s t r o k e m i t e r l i m i t f a c t o r get geom chop gs create stroked shape path p } } { path chop p } } point2 d get center { path get center } point2 d get outermost point { path get path index of outermost node get control point 0 } /** * joins two segments into one the given point2 d hits a node * of the polyline * @return the two segments were joined */ basic join segments point2 d join tolerance { path join segments join tolerance } /** * splits the segment at the given point2 d a segment was hit * @return the index of the segment or 1 no segment was hit */ basic split segment point2 d split tolerance { path split segment split tolerance } /** * handles a mouse click */ handle mouse click point2 d p mouse event evt drawing view view { evt get click count == 2 view get handle detail level == 1 { will change index = basic split segment p 5f / view get scale factor index != 1 { bezier path node node = get node index fire undoable edit happened undoable edit { redo cannot redo { redo will change basic add node index node changed } undo cannot undo { undo will change basic remove node index changed } } changed } } } write dom output out i o { write points out write attributes out } write points dom output out i o { out open element points is closed { out add attribute closed } i=0 n = get node count i < n i++ { bezier path node node = get node i out open element p node mask != 0 { out add attribute mask node mask } ! node keep colinear { out add attribute colinear } out add attribute x node x 0 out add attribute y node y 0 node x 1 != node x 0 || node y 1 != node y 0 { out add attribute c1x node x 1 out add attribute c1y node y 1 } node x 2 != node x 0 || node y 2 != node y 0 { out add attribute c2x node x 2 out add attribute c2y node y 2 } out close element } out close element } @ override read dom input in i o { read points in read attributes in } read points dom input in i o { path clear in open element points set closed in get attribute closed i=0 n = in get element count p i < n i++ { in open element p i bezier path node node = bezier path node in get attribute mask 0 in get attribute x 0d in get attribute y 0d in get attribute c1x in get attribute x 0d in get attribute c1y in get attribute y 0d in get attribute c2x in get attribute x 0d in get attribute c2y in get attribute y 0d node keep colinear = in get attribute colinear path add node path invalidate path in close element } in close element }} 
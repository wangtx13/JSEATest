/* * @ # bezier 2 0 1 2006 06 14 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * */package geom * * geom * /** * provides algorithms fitting bezier curves to a set of digitized points * <p> * source <br> * an algorithm automatically fitting digitized curves * by philip j schneider <br> * from graphics gems academic press 1990 * * @version 2 0 1 2006 06 14 fit bezier curve must preserve closed state of * fitted bezier path * <br>2 0 2006 01 14 changed to support precision coordinates * <br>1 0 march 14 2004 * @author werner randelshofer */public bezier { /** * the most points you can have */ m a x p o i n t s = 1000 /** prevent instance creation */ bezier { } /** * example of how to use the curve fitting given an * of points and a tolerance squared between points and * fitted curve the algorithm will generate a piecewise * cubic bezier representation that approximates the points * when a cubic is generated the routine draw bezier curve * is called which outputs the bezier curve just created * arguments are the degree and the control points respectively * users will have to implement function themselves * ascii output etc * */ { point2 d d = {	/* digitized points */ point2 d 0 0 0 0 point2 d 0 0 0 5 point2 d 1 1 1 4 point2 d 2 1 1 6 point2 d 3 2 1 1 point2 d 4 0 0 2 point2 d 4 0 0 0 } double	error = 4 0 		/* squared */ general path path = fit curve d 	/* fit the bezier curves */ out path } /** * fit a bezier curve to a set of digitized points * * @param p polygon with a set of digitized points * @param user defined squared * @return a general path containing the bezier curves */ general path fit curve polygon p { point2 d d = point2 d p npoints i=0 i < d length i++ { d i = point2 d p xpoints i p ypoints i } fit curve d } /** * fit a bezier curve to a set of digitized points * * @param d of digitized points * @param user defined squared * @return a general path containing the bezier curves */ general path fit curve point2 d d { point2 d t hat1 = point2 d point2 d t hat2 = point2 d /* unit tangent vectors at endpoints */ general path bezier path = general path bezier path move to d 0 x d 0 y t hat1 = compute left tangent d 0 t hat2 = compute right tangent d d length 1 fit cubic d 0 d length 1 t hat1 t hat2 bezier path bezier path } /** * fit a bezier curve to a set of digitized points * * @param path the path onto which to fit a bezier curve * @param user defined squared * @return a bezier path containing the bezier curves */ bezier path fit bezier curve bezier path path { point2 d d = path to polygon point2 d t hat1 = point2 d point2 d t hat2 = point2 d /* unit tangent vectors at endpoints */ bezier path bezier path = bezier path bezier path add bezier path node d 0 t hat1 = compute left tangent d 0 t hat2 = compute right tangent d d length 1 fit cubic d 0 d length 1 t hat1 t hat2 bezier path bezier path set closed path is closed bezier path } /** * fit a bezier curve to a sub set of digitized points * * @param d of digitized points * @param first indice of first point in d * @param last indice of last point in d * @param t hat1 unit tangent vectors at start point * @param t hat2 unit tanget vector at end point * @param user defined squared * @param bezier path path to which the bezier curve segments are added */ fit cubic point2 d d first last point2 d t hat1 point2 d t hat2 general path bezier path { point2 d bez curve /* control points of fitted bezier curve*/ u 		/* parameter values point */ u prime 	/* improved parameter values */ double	max 	/* maximum fitting error	 */ 	split point = 1 /* point to split point set at is an of size one because we need it as an input/output parameter */ int	n pts 		/* number of points in subset */ double	iteration /* below which you iterating */ int	max iterations = 4 /* max times to iterating */ point2 d double	t hat center = point2 d /* unit tangent vector at split point */ int	i iteration = * n pts = last first + 1 /* use heuristic region only has two points in it */ n pts == 2 { dist = v2 distance between2 points d last d first / 3 0 bez curve = point2 d 4 i=0 i < bez curve length i++ { bez curve i = point2 d } bez curve 0 = d first bez curve 3 = d last v2 add bez curve 0 v2 scale t hat1 dist bez curve 1 v2 add bez curve 3 v2 scale t hat2 dist bez curve 2 bezier path curve to bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y } /* parameterize points and attempt to fit curve */ u = chord length parameterize d first last bez curve = generate bezier d first last u t hat1 t hat2 /* find max deviation of points to fitted curve */ max = compute max d first last bez curve u split point max < { bezier path curve to bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y } /* not too large some reparameterization */ /* and iteration */ max < iteration { i = 0 i < max iterations i++ { u prime = reparameterize d first last u bez curve bez curve = generate bezier d first last u prime t hat1 t hat2 max = compute max d first last bez curve u prime split point max < { bezier path curve to bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y } u = u prime } } /* fitting failed split at max point and fit recursively */ t hat center = compute center tangent d split point 0 fit cubic d first split point 0 t hat1 t hat center bezier path v2 negate t hat center fit cubic d split point 0 last t hat center t hat2 bezier path } /** * fit a bezier curve to a sub set of digitized points * * @param d of digitized points * @param first indice of first point in d * @param last indice of last point in d * @param t hat1 unit tangent vectors at start point * @param t hat2 unit tanget vector at end point * @param user defined squared * @param bezier path path to which the bezier curve segments are added */ fit cubic point2 d d first last point2 d t hat1 point2 d t hat2 bezier path bezier path { point2 d bez curve /* control points of fitted bezier curve*/ u 		/* parameter values point */ u prime 	/* improved parameter values */ double	max 	/* maximum fitting error	 */ 	split point = 1 /* point to split point set at is an of size one because we need it as an input/output parameter */ int	n pts 		/* number of points in subset */ double	iteration /* below which you iterating */ int	max iterations = 4 /* max times to iterating */ point2 d double	t hat center = point2 d /* unit tangent vector at split point */ int	i iteration = * n pts = last first + 1 /* use heuristic region only has two points in it */ n pts == 2 { dist = v2 distance between2 points d last d first / 3 0 bez curve = point2 d 4 i=0 i < bez curve length i++ { bez curve i = point2 d } bez curve 0 = d first bez curve 3 = d last v2 add bez curve 0 v2 scale t hat1 dist bez curve 1 v2 add bez curve 3 v2 scale t hat2 dist bez curve 2 bezier path curve to bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y } /* parameterize points and attempt to fit curve */ u = chord length parameterize d first last bez curve = generate bezier d first last u t hat1 t hat2 /* find max deviation of points to fitted curve */ max = compute max d first last bez curve u split point max < { bezier path curve to bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y } /* not too large some reparameterization */ /* and iteration */ max < iteration { i = 0 i < max iterations i++ { u prime = reparameterize d first last u bez curve bez curve = generate bezier d first last u prime t hat1 t hat2 max = compute max d first last bez curve u prime split point max < { bezier path curve to bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y } u = u prime } } /* fitting failed split at max point and fit recursively */ t hat center = compute center tangent d split point 0 fit cubic d first split point 0 t hat1 t hat center bezier path v2 negate t hat center fit cubic d split point 0 last t hat center t hat2 bezier path } /** * use least squares to find bezier control points region * * @param d of digitized points * @param first indice of first point in d * @param last indice of last point in d * @param u prime parameter values region * @param t hat1 unit tangent vectors at start point * @param t hat2 unit tanget vector at end point */ point2 d generate bezier point2 d d first last u prime point2 d t hat1 point2 d t hat2 { 	i point2 d a = point2 d m a x p o i n t s 2 /* precomputed rhs eqn	*/ 	n pts 			/* number of pts in sub curve */ c = 2 2 /* matrix c		*/ x = 2 	/* matrix x			*/ 	det c0 c1 		/* determinants of matrices	*/ det c0 x det x c1 	alpha l 		/* alpha values left and right	*/ alpha r point2 d 	tmp = point2 d /* utility variable		*/ point2 d bez curve 	/* r e t u r n bezier curve ctl pts	*/ bez curve = point2 d 4 i=0 i < bez curve length i++ { bez curve i = point2 d } n pts = last first + 1 /* compute the a's	*/ i = 0 i < n pts i++ { point2 d v1 v2 v1 = point2 d t hat1 clone v2 = point2 d t hat2 clone v2 scale v1 b1 u prime i v2 scale v2 b2 u prime i a i 0 = v1 a i 1 = v2 } /* create the c and x matrices	*/ c 0 0 = 0 0 c 0 1 = 0 0 c 1 0 = 0 0 c 1 1 = 0 0 x 0 = 0 0 x 1 = 0 0 i = 0 i < n pts i++ { c 0 0 += v2 dot a i 0 a i 0 c 0 1 += v2 dot a i 0 a i 1 /*					 c 1 0 += v2 dot a i 0 a i 1 */ c 1 0 = c 0 1 c 1 1 += v2 dot a i 1 a i 1 tmp = v2 sub i i d first + i v2 add i i v2 scale i i i d first b0 u prime i v2 add i i v2 scale i i i d first b1 u prime i v2 add i i v2 scale i i i d last b2 u prime i v2 scale i i i d last b3 u prime i x 0 += v2 dot a i 0 tmp x 1 += v2 dot a i 1 tmp } /* compute the determinants of c and x	*/ det c0 c1 = c 0 0 * c 1 1 c 1 0 * c 0 1 det c0 x = c 0 0 * x 1 c 0 1 * x 0 det x c1 = x 0 * c 1 1 x 1 * c 0 1 /* derive alpha values	*/ det c0 c1 == 0 0 { det c0 c1 = c 0 0 * c 1 1 * 10e 12 } alpha l = det x c1 / det c0 c1 alpha r = det c0 x / det c0 c1 /* alpha negative use the wu/ barsky heuristic see text */ /* alpha is 0 you get coincident control points that to * divide by zero in any subsequent newton raphson root find call */ alpha l < 1 0e 6 || alpha r < 1 0e 6 { dist = v2 distance between2 points d last d first / 3 0 bez curve 0 = d first bez curve 3 = d last v2 add bez curve 0 v2 scale t hat1 dist bez curve 1 v2 add bez curve 3 v2 scale t hat2 dist bez curve 2 bez curve } /* first and last control points of the bezier curve are */ /* positioned exactly at the first and last data points */ /* control points 1 and 2 are positioned an alpha distance out */ /* on the tangent vectors left and right respectively */ bez curve 0 = d first bez curve 3 = d last v2 add bez curve 0 v2 scale t hat1 alpha l bez curve 1 v2 add bez curve 3 v2 scale t hat2 alpha r bez curve 2 bez curve } /** * given set of points and their parameterization to find * a better parameterization * * @param d of digitized points * @param first indice of first point of region in d * @param last indice of last point of region in d * @param u current parameter values * @param bez curve current fitted curve */ reparameterize point2 d d first last u point2 d bez curve { 	n pts = last first+1 	i u prime /* parameter values	*/ u prime = n pts i = first i <= last i++ { u prime i first = newton raphson root find bez curve d i u i first } u prime } /** * use newton raphson iteration to find better root * * @param q current fitted bezier curve * @param p digitized point * @param u parameter value vor p */ newton raphson root find point2 d q point2 d p u { 		numerator denominator point2 d q1 = point2 d 3 q2 = point2 d 2 	/* q' and q''			*/ point2 d double	 q u = point2 d q1 u = point2 d q2 u = point2 d /*u evaluated at q q' q''	*/ 		u prime 		/* improved u	*/ 		i /* compute q u 	*/ q u = bezier i i 3 q u /* generate control vertices q'	*/ i = 0 i <= 2 i++ { q1 i = point2 d q i+1 x q i x * 3 0 q i+1 y q i y * 3 0 } /* generate control vertices q'' */ i = 0 i <= 1 i++ { q2 i = point2 d q1 i+1 x q1 i x * 2 0 q1 i+1 y q1 i y * 2 0 } /* compute q' u and q'' u 	*/ q1 u = bezier i i 2 q1 u q2 u = bezier i i 1 q2 u /* compute f u /f' u */ numerator = q u x p x * q1 u x + q u y p y * q1 u y denominator = q1 u x * q1 u x + q1 u y * q1 u y + q u x p x * q2 u x + q u y p y * q2 u y /* u = u f u /f' u */ u prime = u numerator/denominator u prime } /** * evaluate a bezier curve at a particular parameter value * * @param degree the degree of the bezier curve * @param v of control points * @param t parametric value to find point */ point2 d bezier i i degree point2 d v t { 	i j point2 d q /* point on curve at parameter t	*/ point2 d vtemp /* local copy of control points		*/ /* copy array	*/ vtemp = point2 d degree+1 i = 0 i <= degree i++ { vtemp i = point2 d v i clone } /* triangle computation	*/ i = 1 i <= degree i++ { j = 0 j <= degree i j++ { vtemp j x = 1 0 t * vtemp j x + t * vtemp j+1 x vtemp j y = 1 0 t * vtemp j y + t * vtemp j+1 y } } q = vtemp 0 q } /** * b0 b1 b2 b3 *	 bezier multipliers */ b0 u { tmp = 1 0 u tmp * tmp * tmp } b1 u { tmp = 1 0 u 3 * u * tmp * tmp } b2 u { tmp = 1 0 u 3 * u * u * tmp } b3 u { u * u * u } /** * approximate unit tangents at left endpoint of digitized curve * * @param d digitized points * @param end index to left end of region */ point2 d compute left tangent point2 d d end { point2 d double	t hat1 = point2 d t hat1 = v2 sub i i d end+1 d end t hat1 = v2 normalize t hat1 t hat1 } /** * approximate unit tangents at right endpoint of digitized curve * * @param d digitized points * @param end index to right end of region */ point2 d compute right tangent point2 d d end { point2 d t hat2 = point2 d t hat2 = v2 sub i i d end 1 d end t hat2 = v2 normalize t hat2 t hat2 } /** * approximate unit tangents at center of digitized curve * * @param d digitized points * @param center index to center end of region */ point2 d compute center tangent point2 d d center { point2 d v1 = point2 d v2 = point2 d t hat center = point2 d v1 = v2 sub i i d center 1 d center v2 = v2 sub i i d center d center+1 t hat center x = v1 x + v2 x /2 0 t hat center y = v1 y + v2 y /2 0 t hat center = v2 normalize t hat center t hat center } /** * assign parameter values to digitized points * using relative distances between points * * @param d digitized points * @param first indice of first point of region in d * @param last indice of last point of region in d */ chord length parameterize point2 d d first last { int	i u 	/* parameterization		*/ u = last first+1 u 0 = 0 0 i = first+1 i <= last i++ { u i first = u i first 1 + v2 distance between2 points d i d i 1 } i = first + 1 i <= last i++ { u i first = u i first / u last first } u } /** * find the maximum squared distance of digitized points * to fitted curve * * @param d digitized points * @param first indice of first point of region in d * @param last indice of last point of region in d * @param bez curve fitted bezier curve * @param u parameterization of points* * @param split point point of maximum input/output parameter must be * an of 1 */ compute max point2 d d first last point2 d bez curve u split point { int		i double	max dist 		/* maximum */ double	dist 		/* current */ point2 d double	 p = point2 d /* point on curve */ point2 d double	v = point2 d /* vector from point to curve */ split point 0 = last first + 1 /2 max dist = 0 0 i = first + 1 i < last i++ { p = bezier i i 3 bez curve u i first v = v2 sub i i p d i dist = v2 squared length v dist >= max dist { max dist = dist split point 0 = i } } max dist } point2 d v2 add i i point2 d a point2 d b { point2 d c = point2 d c x = a x + b x c y = a y + b y c } point2 d v2 scale i i i point2 d v s { point2 d result = point2 d result x = v x * s result y = v y * s result } point2 d v2 sub i i point2 d a point2 d b { point2 d c = point2 d c x = a x b x c y = a y b y c } /* * graphics gems c * 2d and 3d vector c library * by andrew glassner * from graphics gems academic press 1990 * */ /** * the distance between two points */ v2 distance between2 points point2 d a point2 d b { dx = a x b x dy = a y b y math sqrt dx*dx + dy*dy } /** * scales the input vector to the length and it */ point2 d v2 scale point2 d v newlen { len = v2 length v len != 0 0 { v x *= newlen/len v y *= newlen/len } v } /** * length of input vector */ v2 length point2 d a { math sqrt v2 squared length a } /** * squared length of input vector */ v2 squared length point2 d a { a x * a x + a y * a y } /** * vector sum c = a+b */ point2 d v2 add point2 d a point2 d b point2 d c { c x = a x+b x c y = a y+b y c } /** * negates the input vector and it */ point2 d v2 negate point2 d v { v x = v x v y = v y v } /** * the dot product of vectors a and b */ v2 dot point2 d a point2 d b { a x*b x + a y*b y } /** * normalizes the input vector and it */ point2 d v2 normalize point2 d v { len = v2 length v len != 0 0 { v x /= len v y /= len } v }} 
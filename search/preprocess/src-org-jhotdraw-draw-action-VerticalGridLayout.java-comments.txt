/* * @ # vertical grid layout 1 0 27 november 2003 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * */package draw action * /** * vertical grid layout * <p> * a grid layout which lays out columns first * * @author werner randelshofer * @version 1 0 27 november 2003 created */public vertical grid layout layout manager io serializable { hgap vgap rows cols is vertical = /** * creates a grid layout with a of one column per component * in a single row */ vertical grid layout { 1 0 0 0 } /** * creates a grid layout with the specified number of rows and * columns all components in the layout are given equal size * <p> * one but not both of <code>rows</code> and <code>cols</code> can * be zero which means that any number of can be placed in a * row or in a column * @param rows the rows with the value zero meaning * any number of rows * @param cols the columns with the value zero meaning * any number of columns */ vertical grid layout rows cols { rows cols 0 0 } vertical grid layout rows cols is vertical { rows cols 0 0 is vertical } vertical grid layout rows cols hgap vgap { rows cols hgap vgap } /** * creates a grid layout with the specified number of rows and * columns all components in the layout are given equal size * <p> * in addition the horizontal and vertical gaps are set to the * specified values horizontal gaps are placed at the left and * right edges and between each of the columns vertical gaps are * placed at the top and bottom edges and between each of the rows * <p> * one but not both of <code>rows</code> and <code>cols</code> can * be zero which means that any number of can be placed in a * row or in a column * <p> * all <code> vertical grid layout</code> constructors defer to one * @param rows the rows with the value zero meaning * any number of rows * @param cols the columns with the value zero meaning * any number of columns * @param hgap the horizontal gap * @param vgap the vertical gap * @exception illegal argument the value of both *			<code>rows</code> and <code>cols</code> is *			set to zero */ vertical grid layout rows cols hgap vgap is vertical { rows == 0 cols == 0 { illegal argument rows and cols cannot both be zero } rows = rows cols = cols hgap = hgap vgap = vgap is vertical = is vertical } /** * gets the number of rows in layout * @return the number of rows in layout * @since j d k1 1 */ get rows { rows } /** * sets the number of rows in layout to the specified value * @param rows the number of rows in layout * @exception illegal argument the value of both * <code>rows</code> and <code>cols</code> is set to zero * @since j d k1 1 */ set rows rows { rows == 0 cols == 0 { illegal argument rows and cols cannot both be zero } rows = rows } set vertical b { is vertical = b } is vertical { is vertical } /** * gets the number of columns in layout * @return the number of columns in layout * @since j d k1 1 */ get columns { cols } /** * sets the number of columns in layout to the specified value * setting the number of columns has no affect on the layout * the number of rows specified by a constructor or by * the <tt>set rows</tt> is non zero in that the number * of columns displayed in the layout is determined by the total * number of components and the number of rows specified * @param cols the number of columns in layout * @exception illegal argument the value of both * <code>rows</code> and <code>cols</code> is set to zero * @since j d k1 1 */ set columns cols { cols == 0 rows == 0 { illegal argument rows and cols cannot both be zero } cols = cols } /** * gets the horizontal gap between components * @return the horizontal gap between components * @since j d k1 1 */ get hgap { hgap } /** * sets the horizontal gap between components to the specified value * @param hgap the horizontal gap between components * @since j d k1 1 */ set hgap hgap { hgap = hgap } /** * gets the vertical gap between components * @return the vertical gap between components * @since j d k1 1 */ get vgap { vgap } /** * sets the vertical gap between components to the specified value * @param vgap the vertical gap between components * @since j d k1 1 */ set vgap vgap { vgap = vgap } /** * adds the specified component with the specified name to the layout * @param name the name of the component * @param comp the component to be added */ add layout component name component comp { } /** * removes the specified component from the layout * @param comp the component to be removed */ remove layout component component comp { } /** * determines the preferred size of the container argument using * grid layout * <p> * the preferred width of a grid layout is the largest preferred * width of any of the components in the container times the number of * columns plus the horizontal padding times the number of columns * plus one plus the left and right insets of the target container * <p> * the preferred height of a grid layout is the largest preferred * height of any of the components in the container times the number of * rows plus the vertical padding times the number of rows plus one * plus the top and bottom insets of the target container * * @param parent the container in which to the layout * @return the preferred dimensions to lay out the * subcomponents of the specified container */ dimension preferred layout size container parent { parent get tree lock { insets insets = parent get insets ncomponents = parent get component count nrows = rows ncols = cols nrows > 0 { ncols = ncomponents + nrows 1 / nrows } { nrows = ncomponents + ncols 1 / ncols } w = 0 h = 0 i = 0 i < ncomponents i++ { component comp = parent get component i dimension d = comp get preferred size w < d width { w = d width } h < d height { h = d height } } dimension insets left + insets right + ncols*w + ncols 1 *hgap insets top + insets bottom + nrows*h + nrows 1 *vgap } } /** * determines the minimum size of the container argument using * grid layout * <p> * the minimum width of a grid layout is the largest minimum width * of any of the components in the container times the number of columns * plus the horizontal padding times the number of columns plus one * plus the left and right insets of the target container * <p> * the minimum height of a grid layout is the largest minimum height * of any of the components in the container times the number of rows * plus the vertical padding times the number of rows plus one plus * the top and bottom insets of the target container * * @param parent the container in which to the layout * @return the minimum dimensions needed to lay out the * subcomponents of the specified container */ dimension minimum layout size container parent { parent get tree lock { insets insets = parent get insets ncomponents = parent get component count nrows = rows ncols = cols nrows > 0 { ncols = ncomponents + nrows 1 / nrows } { nrows = ncomponents + ncols 1 / ncols } w = 0 h = 0 i = 0 i < ncomponents i++ { component comp = parent get component i dimension d = comp get minimum size w < d width { w = d width } h < d height { h = d height } } dimension insets left + insets right + ncols*w + ncols 1 *hgap insets top + insets bottom + nrows*h + nrows 1 *vgap } } /** * lays out the specified container using layout * <p> * reshapes the components in the specified target * container in order to satisfy the constraints of the * <code> vertical grid layout</code> * <p> * the grid layout manager determines the size of individual * components by dividing the free space in the container into * equal sized portions according to the number of rows and columns * in the layout the container's free space equals the container's * size minus any insets and any specified horizontal or vertical * gap all components in a grid layout are given the same size * * @param parent the container in which to the layout * @see container * @see container#do layout */ layout container container parent { parent get tree lock { insets insets = parent get insets ncomponents = parent get component count nrows = rows ncols = cols ltr = parent get component orientation is left to right ncomponents == 0 { } nrows > 0 { ncols = ncomponents + nrows 1 / nrows } { nrows = ncomponents + ncols 1 / ncols } w = parent get width insets left + insets right h = parent get height insets top + insets bottom w = w ncols 1 * hgap / ncols h = h nrows 1 * vgap / nrows i ltr { c = 0 x = insets left c < ncols c++ x += w + hgap { r = 0 y = insets top r < nrows r++ y += h + vgap { is vertical { i = r + c * nrows } { i = r * ncols + c } i < ncomponents { parent get component i set bounds x y w h } } } } { c = 0 x = parent get width insets right w c < ncols c++ x = w + hgap { r = 0 y = insets top r < nrows r++ y += h + vgap { is vertical { i = r + c * nrows } { i = r * ncols + c } i < ncomponents { parent get component i set bounds x y w h } } } } } } /** * the representation of grid layout's values * @return a representation of grid layout */ to { get get name + hgap= + hgap + vgap= + vgap + rows= + rows + cols= + cols + }} 
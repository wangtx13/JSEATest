/* * @ # task figure 1 0 18 juni 2006 * * copyright c 1996 2006 by the original authors of * and all its contributors * all rights reserved * * software is the confidential and proprietary information of * confidential information you shall not disclose * such confidential information and shall use it only in accordance * with the terms of the license agreement you entered into with * */package samples pert figures io i o samples * geom * beans * draw attribute keys * * draw * geom * * xml * /** * task figure * * @author werner randelshofer * @version 1 0 18 juni 2006 created */public task figure graphical composite figure { hash set< dependency figure> dependencies /** * derived attribute we cache it here efficiency reasons */ start time /** * adapter is used to connect a text figure with the name of * the task figure model */ name adapter figure listener { task figure target name adapter task figure target { target = target } figure attribute changed figure event e { we could fire a property change event here in some other would like to observe us target fire property change name e get old value e get value } } duration adapter figure listener { task figure target duration adapter task figure target { target = target } figure attribute changed figure event evt { we could fire a property change event here in some other would like to observe us target fire property change duration e get old value e get value task figure succ target get successors { succ update start time } } } /** creates a instance */ task figure { rectangle figure set layouter vertical layouter rectangle figure name compartment p f = rectangle figure s t r o k e c o l o r set name compartment p f name compartment p f set attribute enabled s t r o k e c o l o r f i l l c o l o r set name compartment p f name compartment p f set attribute enabled f i l l c o l o r list figure name compartment = list figure name compartment p f list figure attribute compartment = list figure separator line figure separator1 = separator line figure apply attributes get presentation figure add name compartment add separator1 add attribute compartment insets2 d insets = insets2 d 4 8 4 8 l a y o u t i n s e t s set name compartment insets l a y o u t i n s e t s set attribute compartment insets text figure name figure name compartment add name figure = text figure f o n t b o l d set name figure name figure set attribute enabled f o n t b o l d text figure duration figure attribute compartment add duration figure = text figure f o n t b o l d set duration figure duration figure set text 0 duration figure set attribute enabled f o n t b o l d text figure start time figure attribute compartment add start time figure = text figure start time figure set editable start time figure set text 0 start time figure set attribute enabled f o n t b o l d apply attributes set attribute enabled s t r o k e d a s h e s resource bundle labels = resource bundle get l a f bundle samples pert labels set name labels get task name set duration 0 start time = 0 dependencies = hash set< dependency figure> name figure add figure listener name adapter duration figure add figure listener duration adapter } collection< handle> create handles detail level { list< handle> handles = linked list< handle> detail level == 0 { handles add move handle relative locator north west handles add move handle relative locator north east handles add move handle relative locator south west handles add move handle relative locator south east handles add connection handle relative locator east dependency figure } handles } set name value { get name figure set text value } get name { get name figure get text } set duration value { old value = get duration get duration figure set text to value old value != value { task figure succ get successors { succ update start time } } } get duration { { value of get duration figure get text } number format e { 0 } } update start time { old value = get start time value = 0 task figure pre get predecessors { value = math max value pre get start time + pre get duration } get start time figure set text to value value != old value { task figure succ get successors { the statement here guards against cyclic task dependencies ! is dependent of succ { succ update start time } } } old value != value { fire area invalidated } } get start time { { value of get start time figure get text } number format e { 0 } } text figure get name figure { text figure list figure get child 0 get child 0 } text figure get duration figure { text figure list figure get child 2 get child 0 } text figure get start time figure { text figure list figure get child 2 get child 1 } apply attributes figure f { map< attribute key object> attr = attributed figure get presentation figure get attributes map entry< attribute key object> entry attr entry set { f set attribute entry get key entry get value } } task figure clone { task figure that = task figure clone that dependencies = hash set< dependency figure> that get name figure add figure listener name adapter that that get duration figure add figure listener duration adapter that that update start time that } read dom input in i o { x = in get attribute x 0d y = in get attribute y 0d w = in get attribute w 0d h = in get attribute h 0d set bounds point2 d x y point2 d x+w y+h read attributes in in open element model in open element name set name in read in close element in open element duration set duration in read in close element in close element } write dom output out i o { rectangle2 d r = get bounds out add attribute x r x out add attribute y r y write attributes out out open element model out open element name out write get name out close element out open element duration out write get duration out close element out close element } get layer { 0 } set< dependency figure> get dependencies { collections unmodifiable set dependencies } add dependency dependency figure f { dependencies add f update start time } remove dependency dependency figure f { dependencies remove f update start time } /** * dependent pert tasks which are directly connected via a * pert dependency to task figure */ list< task figure> get successors { linked list< task figure> list = linked list< task figure> dependency figure c get dependencies { c get start figure == { list add task figure c get end figure } } list } /** * predecessor pert tasks which are directly connected via a * pert dependency to task figure */ list< task figure> get predecessors { linked list< task figure> list = linked list< task figure> dependency figure c get dependencies { c get end figure == { list add task figure c get start figure } } list } /** * the current task is a direct or * indirect dependent of the specified task * the dependency is cyclic then * <code>this</code> is passed as a parameter and every other * task in the cycle */ is dependent of task figure t { == t task figure pre get predecessors { pre is dependent of t { } } } to { task figure# +hash + +get name + +get duration + +get start time }} 